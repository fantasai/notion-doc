
\chapter{Scripting}
\label{chap:tricks}

This chapter documents some additional features of the Ion configuration
and scripting interface that can be used for more advanced scripting than
the basic configuration exlained in chapter \ref{chap:config}.

\section{Hooks and other callbacks}

\subsection{Hooks}
\label{sec:hooks}

Hooks are lists of functions to be called when a certain event occurs.
There are two types of them; normal and ''alternative'' hooks. Normal
hooks do not return anything, but alt-hooks should return a boolean
indicating whether it handled its assigned task succesfully. In the case
that \var{true} is returned, remaining handlers are not called.

Hook handlers are registered by first finding the hook
with \fnref{ioncore.get_hook} and then calling \fnref{WHook.add}
on the (succesfull) result with the handler as parameter. Similarly
handlers are unregistered with \fnref{WHook.remove}. For example:

\begin{verbatim}
ioncore.get_hook("ioncore_snapshot_hook"):add(
    function() print("Snapshot hook called.") end
)
\end{verbatim}

In this example the hook handler has no parameters, but many hook
handlers do. The types of parameters for each hook are listed in
the hook reference, section \ref{sec:hookref}.

\subsection{Placement methods}

In addition to the hooks mentioned above there is (at the moment) 
one callback that is not a hook. It is the function
\code{ionws_placement_method} can be used by scripts to decide
in which frame a newly mapped client window should be placed 
within an already decided on \type{WIonWS}. The function has
three parameters: the workspace, the client window and a boolean
indicating whether the client window's geometry (see
\fnref{WRegion.geom}) was specified by the user by e.g. a
\code{-geometry} command line switch. The function should
return a frame on the workspace or \code{nil} if it made no
decision. For example. the window placement heuristics in 
\file{heuristics.lua} implement this function.

\section{Referring to regions}

\subsection{Direct object references}

All Ion objects are passed to Lua scriptss as 'userdatas', and you may
safely store such object references for future use. The C-side object
may be destroyed while Lua still refers to the object. All exported
functions gracefully fail in such a case, but if you need to explicitly
test that the C-side object still exists, use \fnref{obj_exists}.

As an example, the following short piece of code implements 
bookmarking:

\begin{verbatim}
local bookmarks={}

-- Set bookmark bm point to the region reg
function set_bookmark(bm, reg)
    bookmarks[bm]=reg
end

-- Go to bookmark bm
function goto_bookmark(bm)
    if bookmarks[bm] then
        -- We could check that bookmarks[bm] still exists, if we
        -- wanted to avoid an error message.
        bookmarks[bm]:goto()
    end
end
\end{verbatim}

\subsection{Name-based lookups}

If you want to a single region with an exact known name, use
\fnref{lookup_region}. If you want e.g. a list of all regions,
use \fnref{complete_region}\code{("")}. Both functions accept an
optional argument that can be used to specify that the return region(s)
must be of a more specific type. The convenience functions
\fnref{lookup_clientwin}, \fnref{lookup_workspace},
\fnref{complete_clientwin} and \fnref{complete_workspace} are also
provided.

To get the name of an object, use \fnref{WRegion.name}. Please be
aware, that the names of client windows reflect their titles and
are subject to changes. To change the name of a non-client window
region, use \fnref{WRegion.set_name}.


\section{Alternative winprop selection criteria}

Ion calls the Lua function \code{get_winprop} to find a winprop
table for a window. The sole argument to this function is the
client window. To select winprops by some alternative criterion,
simply redefine this function. The function \fnref{WClientWin.get_ident}
can be used to obtain, the class, instance, role and \code{_ION_KLUDGES}
properties of the window.

%\section{Sample scripts}
%\fname{heuristics.lua}
%\fname{closeorkill.lua}



