
\xchapter{Preliminaries: The Ion class and object hierarchies}
\label{chap:prelim}

Although Ion does not have a truely object-oriented design -- and I,
the author of this document and Ion wouldn't even like such a design -- 
it does have a primitive object oriented design for ''screen objects''.
It is essential for the module writer to learn this object system,
but it should be usefull for the person who just wants to configure
key bindings to learn at least something about Ion's object hierarchy.
When you know the class and object hierarchies, you know how and where
the available functions can be used and how to construct more complex
scripts. Therefore I suggest that you read this short chapter before
skipping on to the more interesting things.


\xsection{Class hierarchy}

One of the most important principles of object-oriented design methodology
is inheritance -- roughly how classes (objects are instances of classes)
extend on others' features. Inheritance gives rise to class hierarchy.
In the case of single-inheritance this hierarchy can be expressed as a
tree where the object at the root is inherited by all others below it
and so on.

Figure \ref{fig:classhierarchy} lists out the Ion class hierarchy and
the classes are explained below:\footnote{If the experimental 
  compile-time option \var{CF_WINDOWED_SCREENS} is set, \type{WScreen}
  then inherits \type{WWindow}.}

\begin{figure}
\begin{verbatim}
    WObj
     |
     |-->WRegion
     |    |
     |    |-->WClientWin
     |    |
     |    |-->WWindow
     |    |    |
     |    |    |-->WRootWin
     |    |    |
     |    |    |-->WGenFrame
     |    |    |    |
     |    |    |    |-->WIonFrame (ionws.so)
     |    |    |    |
     |    |    |    |-->WFloatFrame (floatws.so)
     |    |    |
     |    |    |-->WInput (query.so)
     |    |         |
     |    |         |-->WEdln (query.so)
     |    |         |
     |    |         |-->WMessage (query.so)
     |    |
     |    |-->WGenWS
     |    |    |
     |    |    |-->WIonWS (ionws.so)
     |    |    |
     |    |    |-->WFloatWS (floatws.so)
     |    |
     |    |-->Screen
     |
     |-->WWsSplit
\end{verbatim}
\caption{Ion class hierarchy. The string in parenthesis indicates
  the module in which this class is implemented if not in Ioncore.}
\label{fig:classhierarchy}
\end{figure}

\begin{description}
  \item[\type{WObj}]\indextype{WObj}
    Is the base of Ion's object system.
  \item[\type{WRegion}]\indextype{WRegion}
    is the base class for everything on the screen
    and most actions done on screen objects. Each object of type
    \type{WRegion}  has a size and position relative to the parent
    \type{WRegion}. (More on parents and managers below).
    \begin{description}
      \item[\type{WClientWin}\indextype{WClientWin}] is a class for
	client window objects -- the objects that window managers are
	supposed to manage.
      \item[\type{WWindow}]\indextype{WWindow} is the base class for all
	internal objects having an X window associated to them
	(\type{WClientWins} also have X windows associated to them).
	
      \item[\type{WRootWin}]\indextype{WRootWin} is the class for
	root windows\index{root window} of X screens\index{screen!X}.
	Note that an ''X screen'' or root window is not necessarily a
	single  physical screen\index{screen!physical} as a root window
	may be split over multiple screens when multi-head extensions 
	such as Xinerama\index{Xinerama} are used. (Actually there
	can be only one \type{WRootWin} when Xinerama is used.)
	
      \item[\type{WScreens}]\indextype{WScreen} are objects that should
	correspond to physical screens and may share a root window.
	
      \item[\type{WGenFrame}]\indextype{WGenFrame} is a ''virtual'' (to
	lend the C++ terminology) base class implementing everything in
	common to Ion and PWM (''floating'') style frames and why not others
	if such are ever implemented.
	
      \item[\type{WInput}]\indextype{WInput} is again a virtual base class
	for the different kinds of inputs implemented by the query module
	(the line editor and message display).
	
      \item[\type{WGenWS}]\indextype{WGenWS} like \type{WGenFrame} is a
	virtual base class for the two types of workspaces.
    \end{description}
    
  \item[\type{WWsSplit}]\indextype{WWsSplit} is an object internal to
    \type{WIonWS} implementation.
\end{description}


\xsection{Object hierarchies: \type{WRegion} parents and managers}

Each object of type \type{WRegion} has a parent and possibly a manager
associated to it. The parent\index{parent} for an object is always a 
\type{WWindow} and for \type{WRegion} with an X window (\type{WClientWin},
\type{WWindow}) the parent \type{WWindow} is given by the same relation of
the X windows. For other \type{WRegion}s the relation is not as clear.
There is generally very few restrictions other than the above on the
parent---child relation but the most common is as described in
Figure \ref{fig:parentship}.\footnote{This hierarchy does not hold
  if the compile-time option \var{CF_WINDOWED_SCREENS} is set. In that
  case everything except \type{WRootWin}s  should be below \type{WScreen}s
  as they are windowed objects.}

\begin{figure}
\begin{verbatim}
    WRootWins
     |
     |-->WScreens
     |
     |-->WIonWS:s and WFloatWS:s
     |
     |-->WClientWins in full screen mode
     |
     |-->WIonFrames and WFloatFrames
          |
          |-->WClientWins, including transients
          |
          |-->a possible WEdln or WMessage
\end{verbatim}
\caption{Most common parentship relations}
\label{fig:parentship}
\end{figure}

\type{WRegion}s have very little control over their children as a parent.
The manager\index{manager} \type{WRegion} has much more control over its
managed \type{WRegion}s. Managers, for example, handle resize requests,
focusing and displaying of the managed regions. Indeed the manager---managed
relationship gives a better picture of the logical ordering of objects on
the screen. Again, there are generally few limits, but the most common
hierarchy is given in Figure \ref{fig:managership}. Note that sometimes
the parent and manager are the same object and not all objects may have
a manager (e.g. the dock in the dock module at the time of writing this)
but all have a parent--a screen if not anything else.

\begin{figure}
\begin{verbatim}
    WRootWins
     |
     |-->WScreens
          |
          |-->full screen WClientWins
          |    |
          |    |-->transient WClientWins (dialogs)
          |
          |-->WIonWSs
          |    |
          |    |-->WIonFrames
          |         |
          |         |-->WClientWins
          |         |    |
          |         |    |-->transient WClientWins (dialogs)
          |         |
          |         |-->a possible WEdln or WMessage
          |
          |-->WFloatWSs
               |
               |-->WFloatFrames
                    |
                    |-->WClientWins
                    |
                    |-->a possible WEdln or WMessage
\end{verbatim}
\caption{Most common manager--managed relations}
\label{fig:managership}
\end{figure}

Note how the \type{WClientWin}s managed by \type{WFloatFrame}s don't have
transients managed by them. This is because WFloatWSs choose to handle
transients differently (transients are put in separate frames like normal
windows; in the future they should be stacked above the frame containing the
\code{transient_for} window).
