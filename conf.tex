
\chapter{Configuring Ion with Lua}

This chapter should help the reader configure Ion to her/his liking. As 
the reader probably already knows, Ion uses Lua as a configuration and 
extension language. If you are new to Lua, you might first want to read
the the Lua manual at \url{http://www.lua.org/docs.html} and/or perhaps
some helpfull lua-users wiki pages at \url{http://lua-users.org/wiki/}
and the tutorial pages there (\url{http://lua-users.org/wiki/LuaTutorial}).

Ion's configuration files use so-called anonymous functions extensively. 
If that sounds or the function construct in
\begin{verbatim}
kpress("Mod1+1", function(s) screen_switch_nth(s, 0) end)
\end{verbatim} 
looks confusing to you, please consider reading some Lua documentation.
In particular you might want to look at
\url{http://lua-users.org/wiki/FunctionsTutorial}.

Section \ref{sec:conffiles} is an overview of the multiple configuration
files Ion uses.
How keys and mouse action are bound to functions is described in detail
in \ref{sec:bindings} and in section \ref{sec:winprops} winprops are
explained. For a reference on exported functions, see section
\ref{sec:exports}.

\section{The configuration files}
\label{sec:conffiles}

The development branch of Ion (to which document applies) stores its stock
configuration files in \file{/usr/local/ion-devel/etc/ion-devel/} unless 
you or the OS package maintainer has modified the variables
\code{PREFIX}\index{PREFIX@\code{PREFIX}} or
\code{ETCDIR}\index{ETCDIR@\code{ETCDIR}} in
\file{system.mk}.\index{system.mk@\file{system.mk}}
In the former case you probably know where to find the files and in the
latter the OS package maintainer should have provided documentation to
point to the correct location. If these instructions don't point you
to the correct directory, the command \code{locate ioncore.lua} might help
provided \code{updatedb} has been run recently. User configuration files
go in \file{\~{}/.ion-devel/}. 

Ion always searches user configuration file directory before the stock
configuration file directory for files. Therefore, if you want to change
some setting, it is advised against that you modify the stock configuration
files in-place as subsequent installs of Ion will restore the stock
configuration files. Instead you should always make a copy of the stock
file in \file{\~{}/.ion-devel/} and modify this file.

The ioncore main binary and each module have their own configuration
files that should be used to configure that module. In addition, each
(non-Xinerama)\index{Xinerama} screen may have a separate
\file{draw.lua} configuration file.
When Ioncore looks for this file, it first checks if the file
\file{draw-\$DISPLAY.SCREEN.lua} exists. If it cannot find this file, it
uses \file{draw.lua}. \file{\$DISPLAY} here points to the X display
on which Ion is running. If Ion was started with the \file{-display}
argument, it is this string and otherwise the \var{DISPLAY} environment
variable but with possible screen number removed as this is replaced
with the \file{SCREEN} we're loading the configuration for.

The rest of the configuration files are as follows:

%\newlength{\foolength}
%\settowidth{\foolength}{ioncore-bindings.lua}
%\newlength{\barlength}
%\settowidth{\barlength}{ioncore.luaxxx}

\begin{tabularx}{\linewidth}{
      p{\widthof{ioncore-bindings.lua}}%
      p{\widthof{Loaded from}}%
      X}
    \hline
    File & Loaded from & Description \\
    \hline
    \file{ioncore.lua} & ioncore &
    The main configuration file \\
    %
    \file{ioncore-bindings.lua} & \file{ioncore.lua} &
    Global bindings and bindings that are common to screens and
    all/both workspace modules' frames are configurured here. For
    details, see section \ref{sec:bindings}. \\
    %
    \file{kludges.lua} & \file{ioncore.lua}  &
    Settings to get some apps behave more nicely have been collected here.
    See section \ref{sec:winprops} for details on these ''winprops''. \\
    %
    \file{ionws.lua} & ionws\linebreak module  &
    Configuration file for the ionws module. Bindings specific to the
    workspace and frame classes implemented by this module are
    configured here. \\
    %
    \file{floatws.lua} & floatws\linebreak module  &
    Configuration file for the floatws module. Bindings specific to
    the workspace and frame classes implemented by this module are
    configured here. \\
    %
    \file{query.lua} & query\linebreak module  &
    Configuration file for the query module. Bindings to edit text
    in the queries and some other bindings related to queries and
    messages are defined here. \\
    %
    \file{look-*.lua} & ioncore & 
    Drawing engine configuration files. The \file{draw.lua} files
    as explained above are usually linked to or are copies of one of
    these. \\
\end{tabularx}

Some of the files contain references to the file \file{querylib.lua}.
This file is installed in
\code{SHAREDIR}\index{SHAREDIR@\code{SHAREDIR}}
(\file{/usr/local/ion-devel/share/ion-devel/} by default)
among some other other \file{.lua} files that are an essential part of
Ion's code. Users who only want to change a few settings should not
need to modify the files in this directory. Nevertheless, it is
possible to override the files in \code{SHAREDIR} as it is on the search
path after \code{\~/.ion-devel} and \code{ETCDIR}.

There is one extra file in \code{SHAREDIR} that you may find usefull and
that is not loaded by default. This is \file{compat.lua} and it contains
some wrapper functions for backwards compatibility to make the process of
updating Ion a little less painfull. If you have have modified configuration
files that use some features no longer available in the latest Ion, you may
just load this file (with \code{include("compat.lua")} at the beginning of
\file{ioncore.lua}, for example) instead of immediately updating your
configuration files. However, the wrappers will be removed eventually
(maybe about two months after adding them depending on the rate of new
releases) so you should nevertheless update your configuration files before
this happens.

\section{Keys and rodents}
\label{sec:bindings}

In the stock configuration file setup, most key and mouse bindings are set
from the file \file{ioncore-bindings.lua} while module-specific bindings
are set from the modules' main configuration files (\file{modulename.lua}).
Ion's modules no longer fail to load if the bindings have not been set
during the execution of the module's configuration file, so the bindings
could now be set from elsewhere. In any case, the module must have been
loaded prior to defining any bindings.

The bindings are defined by calling various functions that add a new set
of bindings to a binding group. These functions and descriptions of their
contexts and parameters to bindings handlers are listed in the following 
subsection. Each of the functions listed there has a single argument: a 
table listing the keys and mouse actions to be bind functions to. Section
\ref{sec:binddef} describes how the binding tables can be constructed.

Note that when multiple objects want to handle a binding, the innermost
(when the root window is considered the outermost) active object in the
parent--child hierarchy (see Figure \ref{fig:parentship}) of objects 
gets to handle the action.

\subsection{The binding setup functions}

\subsubsection{Ioncore binding setup functions}

The following binding setup functions are defined by the ioncore
main executable and in the stock configuration file setup, they
are set from the file \file{ioncore-bindings.lua}:

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{global_bindings} & Parameters to handler: \type{WScreen} \\
			    & Description: Bindings that are available all the
			      time. \\
    \fnref{mplex_bindings}  & Parameters to handler: \type{WMPlex} \\
			    & Description: Bindings that are common to all
			      \type{WMPlex}es (screens and frames). Usually
			      only bindings that affect current client window
			      (if any) are set here. \\
    \fnref{genframe_bindings} & Parameters to handler: 
    			      \type{WGenFrame}, [\type{WRegion}] \\
			    & Description: Bindings that are common to all
			      types of frames (but not screens unlike
			      \code{mplex_bindings} above. When a tab has been
			      pressed the \type{WRegion} corresponding to the
			      tab is passed as the extra parameter. \\
\end{tabularx}


\subsubsection{IonWS module binding setup functions}

The following binding setup functions are defined by the IonWS module
and in the stock configuration file setup the bindings are set in
\file{ionws.lua}:

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{ionws_bindings}  & Parameters to handler: 
                              \type{WIonWS}, \type{WRegion} \\
			    & Description: Bindings that are available on the
			      tiled workspaces implemented by this module.
			      The extra parameter to binding handler is the 
			      currently active object on the workspace. \\
    \fnref{ionframe_bindings} & Parameters to handler: 
    			      \type{WIonFrame}, [\type{WRegion}] \\
			    & Description: Bindings that are specific to 
			      the tiled frames. As above, when a tab has been
			      pressed the \type{WRegion} corresponding to the
			      tab is passed as the extra parameter. \\
    \fnref{ionframe_moveres_bindings} & Parameters to handler: 
                              \type{WIonFrame} \\
			    & Description: Resize mode bindings.  Activated 
			      by calling \fnref{ionframe_begin_resize}. Only
			      certain functions may be called here; see the
			      function reference for details. \\
\end{tabularx}

\subsubsection{FloatWS module binding setup functions}

These functions are similar to the ones described in the above section for 
the FloatWS module. The bindings are defined in the configuration file 
\file{floatws.lua}:

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{floatws_bindings}& Parameters to handler: 
    			      \type{WFloatWS}, [\type{WRegion}] \\
			    & Description: Bindings that are available on the
			      conventional workspaces implemented by this 
			      module. The extra parameter to binding handler
			      is the  currently active object on the 
			      workspace, if any. \\
    \fnref{floatframe_bindings} & Parameters to handler: 
    			      \type{WFloatFrame}, [\type{WRegion}] \\
			    & Description: Bindings that are specific to 
			      the the conventional floating frames. \\
    \fnref{floatframe_moveres_bindings} & Parameters to handler:
                              \type{WIonFrame} \\
			    & Description: Keyboard move/resize mode 
			      bindings. Activated by calling the function
			      \fnref{floatframe_begin_resize}. Only certain
			      functions may be called here; see the
			      function reference for details. \\
\end{tabularx}


\subsubsection{Query module binding setup functions}

These functions set the bindings for the query module. The bindings are set 
from the file \file{query.lua}.

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{input_bindings}  & Parameters to handler: \type{WInput} \\
			    & Description: bindings that are common to
			      message and query boxes; stuff to close
			      the box and to scroll message or completions. \\
    \fnref{query_bindings}  & Parameters to handler: \type{WEdln} \\
			    & Description: Bindings to edit text and
			      finish the query.\\
\end{tabularx}

\subsection{Defining the bindings}
\label{sec:binddef}

Each of the functions given above has a single argument: a table
listing other tables describing the bindings. While it is possible
to directly construct these tables, the following convenience
functions are provided. 

Key presses:
\begin{itemize}
    \item \fnref{kpress}\code{(keyspec, func)},
    \item \fnref{kpress_waitrel}\code{(keyspec, func)} and
    \item \fnref{submap}\code{(keyspec)\{ ... more key bindings ... \}}.
\end{itemize}
Mouse actions:
\begin{itemize}
    \item \fnref{mclick}\code{(buttonspec, func, [, area])},
    \item \fnref{mdblclick}\code{(buttonspec, func, [, area])}, 
    \item \fnref{mpress}\code{(buttonspec, func, [, area])} and
    \item \fnref{mdrag}\code{(buttonspec, func, [, area])}.
\end{itemize}

The actions that most of these functions correspond to should be clear
and as explained in the reference, \fnref{kpress_waitrel} is simply
\fnref{kpress} with a flag set instructing Ioncore wait for all
modifiers to be released before processing any further actions.
This is to stop one from accidentally calling e.g.
\fnref{region_close} multiple times in a row. The \fnref{submap}
function actually returns another function that expects a table
as an argument. Alternatively you could use
\code{submap2(keyspec, \{ ... \})}.

The parameters \var{keyspec} and \var{buttonspec} are explained below
in detail. The parameter \var{func} is the handler for the binding.
It should expect as parameter(s) objects the types of which depend
on the context as defined in the above table.

The optional string parameter \var{area} may be used to specify a more
precise location where the mouse action should occur for the binding to
take place.
Currently only \fnref{ionframe_bindings} and \fnref{floatframe_bindings}
support any meaningfull values for this parameter. The allowed values
are in this case
\code{"border"}, \code{"tab"}, \code{"empty_tab"}, \code{"client"} and
\code{nil} (for the whole frame).

\subsection{Key and button specifications}

As seen above, the functions that create key binding specifications require
a \var{keyspec} argument. This argument should be a string containing the
name of a key as listed in the X header file \file{keysymdef.h}%
\footnote{This file can usually be found in the directory
\file{/usr/X11R6/include/X11/}.} without the \code{XK_} prefix.
\index{keysymdef.h@\file{keysymdef.h}}
Most of the key names are quite intuitive while some are not. For example,
the \key{Enter} key on the main part of the keyboard has the less common
name \key{Return} while the one one the numpad is called \key{KP\_Enter}.

The \var{keyspec} string may optionally have multiple ''modifier'' names
followed by a plus sign (\code{+}) as a prefix. X defines the following
modifiers:
\begin{quotation}
\key{Shift}, \key{Control}, \key{Mod1} to \key{Mod5},
\key{AnyModifier} and \key{Lock}.
\index{Shift@\key{Shift}}
\index{Control@\key{Control}}
\index{Mod-n@\key{Mod-n}}
\index{AnyModifier@\key{AnyModifier}}
\index{Lock@\key{Lock}}
\end{quotation}

X allows binding all of these modifiers to almost any key and while this
list of modifiers does not explicitly list keys such as 
\key{Alt}\index{Alt@\key{Alt}} that are common on modern keyboards, such
keys are bound to one of the \key{Mod-n}. On systems running XFree86
\key{Alt} is usually \key{Mod1}. On Suns \key{Mod1} is the diamond key
and \key{Alt} something else. One of the ''flying window'' keys on so
called Windows-keyboards is probably mapped to \key{Mod3} if you have
such a key. Use the program \file{xmodmap}\index{xmodmap@\file{xmodmap}}
to find out what exactly is bound where. \key{AnyModifier} is usually
used in submaps to indicate that it doesn't matter which modifier keys
are pressed, if any.

Ion ignores the \key{Lock} modifier and any \key{Mod-n} modifiers bound
to 
\key{NumLock}\index{NumLock@\key{NumLock}} or
\key{ScrollLock}\index{ScrollLock@\key{ScrollLock}}
by default because such\footnote{Completely useless keys that should be
  gotten rid of in the author's opinion.} locking keys may otherwise
cause confusion.

Button specifications are similar to key definitions but now
instead of specifying modifiers and a key, you specify modifiers
and one of the button names \key{Button1} to
\key{Button5}\index{Button-n@\key{Button-n}}.


\subsection{An example}

As an example, let's look at an extract from the default bindings for
\type{WIonFrame}s:

\begin{verbatim}
ionframe_bindings{
    kpress(DEFAULT_MOD .. "R", ionframe_begin_resize),
    kpress(DEFAULT_MOD .. "S",
           function(frame) ionframe_split(frame, "bottom") end),

    submap(DEFAULT_MOD .. "K"){
        kpress("AnyModifier+X", ionframe_close),
        kpress("AnyModifier+S",
               function(frame) ionframe_split(frame, "right") end),
    },
    
    mclick("Button1", genframe_p_switch_tab, "tab"),
    mdrag("Button1", genframe_p_tabdrag, "tab"),
    mdrag("Button1", genframe_p_resize, "border"),
    
    mclick("Button2", genframe_p_switch_tab, "tab"),
    mdrag("Button2", genframe_p_tabdrag, "tab"),
    
    mdrag(DEFAULT_MOD .. "Button3", genframe_p_resize),
}
\end{verbatim}

\subsection{A further note on the default binding configuration}

The variable \code{DEFAULT_MOD} in the above listing defaults to
\code{"Mod1+"} and is set in \file{ioncore.lua}. Changing this
variable allows to easily change the the modifier used by all bindings
in the default configuration that use modifiers. Quite a few people
prefer to use the Windows keys as modifiers because many applications
already use \key{Alt}. Nevertheless, \key{Mod1} is the default as a
key bound to it is available virtually everywhere.

\subsection{Client window bindings}

As client windows do not have function to set their bindings, it is
necessary to call client window functions by specifying the bindings
somewhere else. In the stock configuration file setup this is done
in \fnref{mplex_bindings} by functions that look up the object currently
displayed by the \type{WMPlex} (\fnref{mplex_current}). We then check that
it is of type \type{WClientWin} to suppress warning and then call the
wanted function with the verified client window as argument. 

To make it easier to write such bindings, the function 
\fnref{make_current_clientwin_fn} is used to construct this wrapper
function. The following two binding definitions are equivalent:

\begin{verbatim}
mplex_bindings {
    kpress("Mod1+Return", function(mplex)
                              local r=mplex_current(scr)
                              if obj_is(r, "WClientWin") then
                                  clientwin_toggle_fullscreen(r)
                              end
                          end),
    kpress("Mod1+Enter", 
           make_current_clientwin_fn(clientwin_toggle_fullscreen)),
}
\end{verbatim}

%In the stock configuration files, a similar function
%\fnref{make_current_or_self_fn} is also used to create a wrapper for
%\fnref{region_close} that attempts to close the current object managed
%by the \type{WMPlex} if it exists and otherwise the multiplexer itself.


\section{Winprops}
\label{sec:winprops}

\subsection{Classes, roles and instances}

The so-called ''winprops''\index{Winprops} can be used to change how
specific windows are handled and to set up some kludges to deal with
badly behaving applications. They are defined by calling the function
\code{winprop} with a table containing the properties to set and the
necessary information to identify a window. This identification
information is more specifically the
\var{class}\index{class@\var{class}!winprop},
\var{role}\index{role@\var{role}!winprop} and
\var{instance}\index{instance@\var{instance}!winprop}
of the window. It is not necessary to specify all of these; if one is
not specified or is the string \code{"*"} that particular field matches
all windows. For a window with identification information \var{id}, Ion
looks for a matching winprop in the following order:
%\begin{verbatim}
%for _, c in {id.class, "*"} do
%    for _, r in {id.role, "*"} do
%        for _, i in {id.instance, "*"} do
%            -- Check for winprop matching (c, r, i)
%        end
%    end
%end
%\end{verbatim}

\begin{enumerate}
    \item \code{class, role, instance}
    \item \code{class, role, "*"}
    \item \code{class, "*", instance}
    \item \code{class, "*", "*"}
    \item \code{"*", role, instance}
    \item \code{"*", role, "*"}
    \item \code{"*", "*", instance}
    \item \code{"*", "*", "*"}
\end{enumerate}
Here \var{class}, \var{role} and \var{instance} are those of the
client window or \code{"*"} if unset.

To get this identification information for a particular window, you
may use the command \command{xprop WM_CLASS} and click on that
particular window.\footnote{This does not work for transients in
WIonFrames.} The class is the latter of the strings while
the instance is the former. To get the role -- few windows have
this property -- use the command \command{xprop WM_ROLE}.

\subsection{Supported winprops}

Ion currently knows the following winprops:

\index{switchto@\var{switchto}!winprop}
\index{transient-mode@\var{transient_mode}!winprop}
\index{target@\var{target}!winprop}
\index{transparent@\var{transparent}!winprop}
\index{acrobatic@\var{acrobatic}!winprop}
\index{max-size@\var{max_size}!winprop}
\index{aspect@\var{aspect}!winprop}
\index{ignore-resizeinc@\var{ignore_resizeinc}}

\begin{tabularx}{\textwidth}{llX}
    \hline
    Property & Type & Description\\\hline
    \var{switchto} &
    	boolean &
    	Should the window be switched to when it is created. \\
    \var{transient_mode} &
  	string &
    	"normal": No change in behaviour. "current": The window
	should be thought of as a transient for the current active
	client window (if any) even if it is not marked as a
	transient by the application. "off": The window should be
	handled as a normal window even if it is marked as a
	transient by the application. \\
    \var{target} &
    	string &
    	The name of an object (workspace, frame) that should manage 
	windows of this type. \\
    \var{transparent} &
    	boolean &
    	Should frames be made transparent when this window is selected? \\
    \var{acrobatic} &
    	boolean &
    	Set this to \code{true} for Acrobat Reader. It has an annoying
	habit of trying to manage its dialogs instead of setting them as
	transients and letting the window manager do its job, causing
	Ion and acrobat go a window-switching loop when a dialog is
	opened. \\
    \var{max_size} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied maximum size hint. \\
    \var{aspect} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied aspect ratio hint. \\
    \var{ignore_resizeinc} &
    	boolean &
    	Should application supplied size increments be ignored? \\
    \var{fullscreen} &
    	boolean &
    	Should the window be initially in full screen mode? \\
\end{tabularx}

\subsection{Examples}

Acrobat Reader's manners aren't exactly good:
\begin{verbatim}
winprop{
    class = "AcroRead",
    instance = "documentShell",
    acrobatic = true,
}
\end{verbatim}

Place xterm started with '\code{-name sysmon}' and running a system
monitoring program in a specific frame:
\begin{verbatim}
winprop{
    class = "XTerm",
    instance = "sysmon",
    target = "sysmonframe",
}
\end{verbatim}


\section{QueryLib}
\index{QueryLib@\var{QueryLib}}

While the query module only exports the primitive function
\fnref{query_query}, QueryLib (file \file{querylib.lua}) implements some
standard queries, most with completion support. These functions can be 
directly passed to the binding setup functions for classes based on 
\type{WMPlex}.  These setup functions are at the moment:
\begin{itemize}
\item \fnref{global_bindings}
\item \fnref{mplex_bindings}, 
\item \fnref{genframe_bindings},
\item \fnref{ionframe_bindings} and
\item \fnref{floatframe_bindings}.
\end{itemize}

The default configuration puts most queries in \fnref{genframe_bindings}
while the exit and restart queries are in \fnref{global_bindings}.
For a listing of the functions, see section \ref{sec:querylibref} in the 
Function referece. 
