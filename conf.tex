
\chapter{Basic configuration}
\label{chap:config}

This chapter should help the reader configure Ion to her/his liking. As 
the reader probably already knows, Ion uses Lua as a configuration and 
extension language. If the reader is new to Lua, he might first want
to read some Lua documentation as already suggested and pointed to in the
Introduction before continuing with this chapter.

In particular, if ''anonymous function'' sounds or the function construct in
\begin{verbatim}
kpress("Mod1+1", function(s) screen_switch_nth(s, 0) end)
\end{verbatim}
looks confusing to you, please consider reading some Lua documentation,
\url{http://lua-users.org/wiki/FunctionsTutorial} if nothing else.
Ion's stock configuration files use anonymous functions quite extensively.

Section \ref{sec:conffiles} is an overview of the multiple configuration
files Ion uses and as a perhaps more understandable introduction to the
general layout of the configuration files, a walk-through of the main 
configuration file \file{ioncore.lua} is provided in section 
\ref{sec:walkthrough}.
How keys and mouse action are bound to functions is described in detail
in \ref{sec:bindings} and in section \ref{sec:winprops} winprops are
explained. For a reference on exported functions, see section
\ref{sec:exports}.

\section{The configuration files}
\label{sec:conffiles}

The development branch of Ion (to which document applies) stores its stock
configuration files in \file{/usr/local/ion-devel/etc/ion-devel/} unless 
you, OS package maintainer or whoever installed the package has modified 
the variables
\code{PREFIX}\index{PREFIX@\code{PREFIX}} or
\code{ETCDIR}\index{ETCDIR@\code{ETCDIR}} in
\file{system.mk}\index{system.mk@\file{system.mk}} before compiling Ion.
In the first case you probably know where to find the files and in 
the other case the system administrator or OS package maintainer should 
have provided documentation to point to the correct location. If these
instructions are no help in locationthe correct directory, the command
\code{locate ioncore.lua} might help provided \code{updatedb} has been
run recently. User configuration files go in \file{\~{}/.ion-devel/}. 

Ion always searches user configuration file directory before the stock
configuration file directory for files. Therefore, if you want to change
some setting, it is advised against that you modify the stock configuration
files in-place as subsequent installs of Ion will restore the stock
configuration files. Instead you should always make a copy of the stock
file in \file{\~{}/.ion-devel/} and modify this file. When searching
for a file, if no extension or path component is given, compiled \file{.lc} 
files are attempted before \file{.lua} files.

The ioncore main binary and each module have their own configuration
files that should be used to configure that module. The configuration
files related to the ioncore main binary are as follows. The files
\file{ioncore.lua} and \file{draw.lua} are loaded from Ioncore and the
rest are included from the former.

\begin{tabularx}{\linewidth}{
      p{\widthof{ioncore-bindings.lua}}%
      X}
    \hline
    File & Description \\
    \hline
    \file{ioncore.lua} & 
    The main configuration file \\
    %
    \file{ioncore-bindings.lua} & 
    Most of Ion's bindings are configured here. Bindings that are
    specific to some module are configured in the module's configuration
    file. For details, see section \ref{sec:bindings}. \\
    \file{ioncore-menus.lua} & 
    Menu definitions; see section \ref{sec:menus}. \\
    %
    \file{kludges.lua} & 
    Settings to get some apps behave more nicely have been collected here.
    See section \ref{sec:winprops} for details on these ''winprops''. \\
    %
    \file{draw.lua} &
    This file is a link to or copy of one of the \file{look-*.lua} style
    files. It should load a drawing engine and configure a style for
    it; for details see chapter \ref{chap:gr}. \\
\end{tabularx}

Each (non-drawing engine) module has in addition its own configuration
file loaded when that module is loaded:

\begin{tabularx}{\linewidth}{
      p{\widthof{ioncore-bindings.lua}}%
      X}
    \hline
    File & Description \\
    \hline
    \file{ionws.lua} & 
    Configuration file for the ionws module. Bindings specific to the
    workspace and frame classes implemented by this module are
    configured here. \\
    %
    \file{floatws.lua} & 
    Configuration file for the floatws module. Bindings specific to
    the workspace and frame classes implemented by this module are
    configured here. \\
    %
    \file{query.lua} & 
    Configuration file for the query module. Bindings to edit text
    in the queries and some other bindings related to queries and
    messages are defined here. \\
    %
    \file{menu.lua} & 
    Configuration file for the menu module. Bindings to navigate
    menus are defined here. Actual menus are (in the stock
    configuration file setup) defined in \file{ioncore-menus.lua}
    as mentioned above. \\
\end{tabularx}

Some of the files contain references to the files \file{querylib.lua}
and \file{menulib.lua}
These are installed in
\code{SHAREDIR}\index{SHAREDIR@\code{SHAREDIR}}
(\file{/usr/local/ion-devel/share/ion-devel/} by default)
among some other other \file{.lua} files that are an essential part of
Ion's code. Users who only want to change a few settings should not
need to modify the files in this directory. Nevertheless, it is
possible to override the files in \code{SHAREDIR} as it is on the search
path after \code{\~/.ion-devel} and \code{ETCDIR}.

There is one extra file in \code{SHAREDIR} that you may find usefull and
that is not loaded by default. This is \file{compat.lua} and it contains
some wrapper functions for backwards compatibility to make the process of
updating Ion a little less painfull. If you have have modified configuration
files that use some features no longer available in the latest Ion, you may
just load this file (with \code{include("compat.lua")} at the beginning of
\file{ioncore.lua}, for example) instead of immediately updating your
configuration files. However, the wrappers will be removed eventually
(maybe about two months after adding them depending on the rate of new
releases) so you should nevertheless update your configuration files before
this happens.

\section{A walk through \file{ioncore.lua}}
\label{sec:walkthrough}

As already mentioned \file{ioncore.lua} is Ion's main configuration
file. Some basic 'feel' settings are usually configured there and
the necessary modules and other configuration files configuring some 
more specific aspects of Ion are loaded there. In this section we
take a walk through the stock \file{ioncore.lua}.

The first thing that is done in that file is set
\begin{verbatim}
DEFAULT_MOD = "Mod1+"
\end{verbatim}
This causes most of Ion's key bindings to use \key{Mod1} as the
modifier key; for details on modifiers and key binding setup in 
general see section \ref{sec:bindings}.

Next there are the commented-out delay settings
\begin{verbatim}
-- set_dblclick_delay(250)
-- set_resize_delay(1500)
\end{verbatim}
The first of these settings is the maximum interlval in milliseconds 
between two mouse button presses for the second press to be actually
considered a double-click. The latter setting sets the delay, again 
in milliseconds, after which Ion will automatically terminate 
one of the keyboard resize modes if nothing has happened. 

The setting
\begin{verbatim}
enable_opaque_resize(false)
\end{verbatim}
says that a XOR rubberband should be shown when moving or resizing
frames. This will, unfortunately, cause Ion to also grab the X
server and has some side effects. If your computer is fast enough
and you prefer so-called ''opaque resize'' mode where the frame is
being resized already during the resize action  you may set the parameter
to \verb!true!.

The following settings controls whether Ion will ''warp'' the (mouse)
pointer to an object whenever it is focused from the keyboard. 
\begin{verbatim}
enable_warp(true)
\end{verbatim}
Some people may consider this annoying so setting the parameter
to \verb!false! can be used to disable this feature and have Ion
never move the pointer.

Next the stock \file{ioncore.lua} has the include-statements
\begin{verbatim}
include("kludges")
include("ioncore-bindings")
include("ioncore-menus")
\end{verbatim}
The first of these loads the file \file{kludges.lua} that contains
some ''winprop'' settings used to make some applications behave a
little better under Ion. For details see section \ref{sec:winprops}.
The second include statement loads file file 
\file{ioncore-bindings.lua} which containts the statements to configure 
most of Ion's bindings; modules' bindings are configured in their 
respective configuration files. The final include statement load
menu definitions.

Next we have quite a few statements of the form
\begin{verbatim}
add_shortenrule("[^:]+: (.*)(<[0-9]+>)", "$1$2$|$1$<...$2")
\end{verbatim}
These are used to configure how Ion attempts to shorten window titles
when they do not fit in a Tab. The first argument is a POSIX regular
expression that is used to match against the title and the next is
a rule to construct a new title of a match occurs. This particular
rule is used to shorten e.g. 'Foo: barbaz<3>' to 'barba{\ldots}<3>'; for
details see the function reference entry for \fnref{add_shortenrule}.

The settings
\begin{verbatim}
query_ssh_hosts = { "host1", "host2" }
query_man_path = {
    "/usr/man",
    "/usr/share/man",
    "/usr/X11R6/man",
    "/usr/local/man"
}
\end{verbatim}
are, respectively, used to configure the hosts the \fnref{querylib.query_ssh} 
query  (\key{F4} key in the stock configuration) knows to tab-complete and 
the where the \fnref{querylib.query_man} query (\key{F1}) knows to look for
man pages to tab-complete.

Finally we load the modules.
\begin{verbatim}
load_module("query")
load_module("menu")
load_module("ionws")
load_module("floatws")
\end{verbatim}
The first of the modules provides the queries, the minibuffer-like
line-editor boxes that appear at bottoms of frames and screens and that
can be and are used to to do quite a few things including starting
programs and navigating to different windows by their name.
The 'menu' module provides both pop-up and query-style in-frame menus.
The third module loaded provides the normal Ion-style tiled workspaces
and frames of that style while the 'floatws' module provides traditional
''free-floating'' WIMP workspaces and frames in the PWM style.

As already mentioned, each of these modules have their own configuration
files \file{modulename.lua} that configure things that can only be
configured if the module is loaded. These settings are mostly just the
bindings that are specific to the classes provided by the module.

At the moment there are no other modules than the above three. Any of
these modules may be removed; Ion is able to operate without any modules
in full-screen  only mode, but if you do so, you might first want to 
reconfigure some of the bindings. Ion will, however, complain of broken
workspace savefiles if starting a module-less configuration over an old
session.

\section{Keys and rodents}
\label{sec:bindings}

In the stock configuration file setup, most key and mouse bindings are set
from the file \file{ioncore-bindings.lua} while module-specific bindings
are set from the modules' main configuration files (\file{modulename.lua}).
This, however, does not have to be so as long as the module has been
loaded prior to defining any module-specific bindings.
%Ion's modules no longer fail to load if the bindings have not been set
%during the execution of the module's configuration file, so the bindings
%could now be set from elsewhere. In any case, the module must have been
%loaded prior to defining any bindings.

The bindings are defined by calling various functions that add a new set
of bindings to a binding group, usually related to some object class.
These functions, descriptions of their contexts and parameters passed to 
''bindings handlers'' are listed in the following subsection. 
Each of the functions listed there has a single argument: a table listing
the keys and mouse actions to bind functions to. Section
\ref{sec:binddef} describes how the binding tables can be constructed.

Note that when multiple objects want to handle a binding, the innermost
(when the root window is considered the outermost) active object in the
parent--child hierarchy (see Figure \ref{fig:parentship}) of objects 
gets to handle the action.

\subsection{The binding setup functions}

This section simply lists out the different binding setup functions
Ioncore and the modules provide and does not even attempt to describe
how to use these functions; for that refer to \ref{sec:binddef} and
following sections.

There has been some confusion among users about the need for multiple, 
partially even overlapping functions to setup bindings so let me try
give reasons for this design decision here. 

The thing is that if there was a just a single 'bind this key
to this function' method to bind keys, some limitations would have to
be made on the available functions or writing custom functions would
be more complicated. In addition one may want to bind the same function
to different key for different types of object. Indeed, the workspace
and frame tab swithing functions are the same both classes being based
on \type{WMPlex}, and in the stock configuration the switch to $n$:th 
workspaces is bound to \key{Mod1+n} (using \fnref{global_bindings}
explained below) while the switch to $n$:th tab is bound to the
sequence \key{Mod1+k n}  (using \fnref{genframe_bindings} and 
\fnref{submap}). Of course all this inheritance could be hidden
from the configuration interface by duplicating functions, but then
at what level this should be then done? There would quickly be a lot
of essentially same functions (\code{screen_switch_nth},
\code{genframe_switch_nth}, \code{ionframe_switch_nth},
\code{floatframe_switch_nth}, and so on for every new type of 
multiplexer added) and that prospect does not look so good.

So, in brief this little additional complexity in configuration is the
price for flexibility and in part elegance (if there can be said to be
anything of the like in Ion).

\subsubsection{Ioncore binding setup functions}

The following binding setup functions are defined by the ioncore
main executable and in the stock configuration file setup, they
are set from the file \file{ioncore-bindings.lua}:

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{global_bindings} & Parameters to handler: \type{WScreen} \\
			    & Description: Bindings that are available all the
			      time. \\
    \fnref{mplex_bindings}  & Parameters to handler: \type{WMPlex} \\
			    & Description: Bindings that are common to all
			      \type{WMPlex}es (screens and frames). Usually
			      only bindings that affect current client window
			      (if any) are set here. \\
    \fnref{genframe_bindings} & Parameters to handler: 
    			      \type{WGenFrame}, [\type{WRegion}] \\
			    & Description: Bindings that are common to all
			      types of frames (but not screens unlike
			      \code{mplex_bindings} above. When a tab has been
			      pressed the \type{WRegion} corresponding to the
			      tab is passed as the extra parameter. \\
\end{tabularx}


\subsubsection{IonWS module binding setup functions}

The following binding setup functions are defined by the IonWS module
and in the stock configuration file setup the bindings are set in
\file{ionws.lua}:

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{ionws_bindings}  & Parameters to handler: 
                              \type{WIonWS}, \type{WRegion} \\
			    & Description: Bindings that are available on the
			      tiled workspaces implemented by this module.
			      The extra parameter to binding handler is the 
			      currently active object on the workspace. \\
    \fnref{ionframe_bindings} & Parameters to handler: 
    			      \type{WIonFrame}, [\type{WRegion}] \\
			    & Description: Bindings that are specific to 
			      the tiled frames. As above, when a tab has been
			      pressed the \type{WRegion} corresponding to the
			      tab is passed as the extra parameter. \\
    \fnref{ionframe_moveres_bindings} & Parameters to handler: 
                              \type{WIonFrame} \\
			    & Description: Resize mode bindings.  Activated 
			      by calling \fnref{WIonFrame.begin_resize}. Only
			      certain functions may be called here; see the
			      function reference for details. \\
\end{tabularx}

\subsubsection{FloatWS module binding setup functions}

These functions are similar to the ones described in the above section for 
the FloatWS module. The bindings are defined in the configuration file 
\file{floatws.lua}:

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{floatws_bindings}& Parameters to handler: 
    			      \type{WFloatWS}, [\type{WRegion}] \\
			    & Description: Bindings that are available on the
			      conventional workspaces implemented by this 
			      module. The extra parameter to binding handler
			      is the  currently active object on the 
			      workspace, if any. \\
    \fnref{floatframe_bindings} & Parameters to handler: 
    			      \type{WFloatFrame}, [\type{WRegion}] \\
			    & Description: Bindings that are specific to 
			      the the conventional floating frames. \\
    \fnref{floatframe_moveres_bindings} & Parameters to handler:
                              \type{WIonFrame} \\
			    & Description: Keyboard move/resize mode 
			      bindings. Activated by calling the function
			      \fnref{WFloatFrame.begin_resize}. Only certain
			      functions may be called here; see the
			      function reference for details. \\
\end{tabularx}


\subsubsection{Query module binding setup functions}

These functions set the bindings for the query module. The bindings are set 
from the file \file{query.lua}.

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{input_bindings}  & Parameters to handler: \type{WInput} \\
			    & Description: bindings that are common to
			      message and query boxes; stuff to close
			      the box and to scroll message or completions. \\
    \fnref{query_bindings}  & Parameters to handler: \type{WEdln} \\
			    & Description: Bindings to edit text and
			      finish the query.\\
\end{tabularx}


\subsubsection{Menu module binding setup functions}

These functions set the bindings for the menu module. The bindings are set 
from the file \file{menu.lua}.

\begin{tabularx}{\linewidth}{lX}
    \hline
    Function & Handler parameters and description \\
    \hline
    \fnref{menu_bindings}  & Parameters to handler: \type{WMenu} \\
			   & Description: key bindings available in in-frame 
			     menus. \\
\end{tabularx}

\subsection{Defining the bindings}
\label{sec:binddef}

Each of the functions listed above has a single argument: a table listing
the key presses and other actions to be bound to functions. The descriptions
of individual bindings in this table are also tables that can be more 
conveniently constructed with the following functions:

Key presses:
\begin{itemize}
    \item \fnref{kpress}\code{(keyspec, func)},
    \item \fnref{kpress_waitrel}\code{(keyspec, func)} and
    \item \fnref{submap}\code{(keyspec)\{ ... more key bindings ... \}}.
\end{itemize}
Mouse actions:
\begin{itemize}
    \item \fnref{mclick}\code{(buttonspec, func, [, area])},
    \item \fnref{mdblclick}\code{(buttonspec, func, [, area])}, 
    \item \fnref{mpress}\code{(buttonspec, func, [, area])} and
    \item \fnref{mdrag}\code{(buttonspec, func, [, area])}.
\end{itemize}

The actions that most of these functions correspond to should be clear
and as explained in the reference, \fnref{kpress_waitrel} is simply
\fnref{kpress} with a flag set instructing Ioncore wait for all
modifiers to be released before processing any further actions.
This is to stop one from accidentally calling e.g.
\fnref{WRegion.close} multiple times in a row. The \fnref{submap}
function actually returns another function that expects a table
as an argument if called with only one argument. Alternatively you
could use \code{submap(keyspec, \{ ... \})}.

The parameters \var{keyspec} and \var{buttonspec} are explained below
in detail. The parameter \var{func} is the handler for the binding.
It is a reference to a function that should expect as parameter(s)
objects of the type defined in the above tables depending on which 
binding  setup function this binding definition is being passed to.

The optional string parameter \var{area} may be used to specify a more
precise location where the mouse action should occur for the binding to
take place.
Currently only \fnref{ionframe_bindings} and \fnref{floatframe_bindings}
support any meaningfull values for this parameter. The allowed values
are in this case
\code{"border"}, \code{"tab"}, \code{"empty_tab"}, \code{"client"} and
\code{nil} (for the whole frame).

\subsection{An example}

For example, to just bind the key \key{Mod1+1} to switch to the first
workspace and \key{Mod1+n} to the next workspace, you would make the
following call
\begin{verbatim}
global_bindings{
    kpress("Mod1+n", WScreen.switch_nth),
    kpress("Mod1+1", function (scr) scr:switch_nth(1) end),
}
\end{verbatim}

Recall that \code{global_bindings\{...\}} is syntactical sugar for
the more cumbersome
\code{global_bindings(\{...\})}.

The first definition works, because \code{WScreen.switch_next}
(inherited \fnref{WMPlex.switch_next}) is a function that takes a 
\type{WScreen} as its sole parameter. On the other hand,
\code{WScreen.switch_nth} (again inherited \fnref{WMPlex.switch_nth}) 
expects two parameters: the screen and the $n$ giving the number of
the workspace to switch to so it could not be directly passed to
\code{kpress}. Therefore we had to write our ''anonymous'' wrapper
function around it tha takes a single parameter and calls
\code{switch_nth} properly. (Recall that \code{scr:switch_nth(1)}
is syntactic sugar for \code{WScreen.switch_nth(scr, 1)}.
Alternatively we could have defined
\code{function switch_1(scr) scr:switch_nth(1) end} before the call
to \code{global_bindings} and passed \code{switch_1} to \code{kpress}
instead of the anonymous function.)

\subsection{Key and button specifications}

As seen above, the functions that create key binding specifications require
a \var{keyspec} argument. This argument should be a string containing the
name of a key as listed in the X header file \file{keysymdef.h}%
\footnote{This file can usually be found in the directory
\file{/usr/X11R6/include/X11/}.} without the \code{XK_} prefix.
\index{keysymdef.h@\file{keysymdef.h}}
Most of the key names are quite intuitive while some are not. For example,
the \key{Enter} key on the main part of the keyboard has the less common
name \key{Return} while the one one the numpad is called \key{KP\_Enter}.

The \var{keyspec} string may optionally have multiple ''modifier'' names
followed by a plus sign (\code{+}) as a prefix. X defines the following
modifiers:
\begin{quotation}
\key{Shift}, \key{Control}, \key{Mod1} to \key{Mod5},
\key{AnyModifier} and \key{Lock}.
\index{Shift@\key{Shift}}
\index{Control@\key{Control}}
\index{Mod-n@\key{Mod-n}}
\index{AnyModifier@\key{AnyModifier}}
\index{Lock@\key{Lock}}
\end{quotation}

X allows binding all of these modifiers to almost any key and while this
list of modifiers does not explicitly list keys such as 
\key{Alt}\index{Alt@\key{Alt}} that are common on modern keyboards, such
keys are bound to one of the \key{Mod-n}. On systems running XFree86
\key{Alt} is usually \key{Mod1}. On Suns \key{Mod1} is the diamond key
and \key{Alt} something else. One of the ''flying window'' keys on so
called Windows-keyboards is probably mapped to \key{Mod3} if you have
such a key. Use the program \file{xmodmap}\index{xmodmap@\file{xmodmap}}
to find out what exactly is bound where. \key{AnyModifier} is usually
used in submaps to indicate that it doesn't matter which modifier keys
are pressed, if any.

Ion ignores the \key{Lock} modifier and any \key{Mod-n} modifiers bound
to 
\key{NumLock}\index{NumLock@\key{NumLock}} or
\key{ScrollLock}\index{ScrollLock@\key{ScrollLock}}
by default because such\footnote{Completely useless keys that should be
  gotten rid of in the author's opinion.} locking keys may otherwise
cause confusion.

Button specifications are similar to key definitions but now
instead of specifying modifiers and a key, you specify modifiers
and one of the button names \key{Button1} to
\key{Button5}\index{Button-n@\key{Button-n}}.


\subsection{Another example}

TODO

\subsection{A further note on the default binding configuration}

The variable \code{DEFAULT_MOD} in the above listing defaults to
\code{"Mod1+"} and is set in \file{ioncore.lua}. Changing this
variable allows to easily change the the modifier used by all bindings
in the default configuration that use modifiers. Quite a few people
prefer to use the Windows keys as modifiers because many applications
already use \key{Alt}. Nevertheless, \key{Mod1} is the default as a
key bound to it is available virtually everywhere.

\subsection{Client window bindings}

As client windows do not have function to set their bindings, it is
necessary to call client window functions by specifying the bindings
somewhere else. In the stock configuration file setup this is done
in \fnref{mplex_bindings} by functions that look up the object currently
displayed by the \type{WMPlex} (\fnref{WMPlex.current}). We then check that
it is of type \type{WClientWin} to suppress warning and then call the
wanted function with the verified client window as argument. 

To make it easier to write such bindings, the function 
\fnref{make_mplex_clientwin_fn} is used to construct this wrapper
function. The following two binding definitions are essentially
equivalent:

\begin{verbatim}
mplex_bindings {
    kpress("Mod1+Return", function(mplex, r)
                              if not r or r==mplex
                                  r=mplex:current()
                              end
                              if obj_is(r, "WClientWin") then
                                  r:toggle_fullscreen()
                              end
                          end),
    kpress("Mod1+Enter",
           make_mplex_clientwin_fn(WClientWin.toggle_fullscreen)),
}
\end{verbatim}

%In the stock configuration files, a similar function
%\fnref{make_current_or_self_fn} is also used to create a wrapper for
%\fnref{region_close} that attempts to close the current object managed
%by the \type{WMPlex} if it exists and otherwise the multiplexer itself.


\section{Winprops}
\label{sec:winprops}

\subsection{Classes, roles and instances}

The so-called ''winprops''\index{Winprops} can be used to change how
specific windows are handled and to set up some kludges to deal with
badly behaving applications. They are defined by calling the function
\code{winprop} with a table containing the properties to set and the
necessary information to identify a window. This identification
information is more specifically the
\var{class}\index{class@\var{class}!winprop},
\var{role}\index{role@\var{role}!winprop} and
\var{instance}\index{instance@\var{instance}!winprop}
\var{name}
of the window. The \var{name} field is a Lua-style regular expression
matched against the window's title and the rest are strings that must
exactly much the corresponding window information. It is not necessary
to specify all of these fields.

Ion looks for a matching winprop in the order listed by the following
table. An 'E' indicates that the field must be set in the winprop
and it must match the window's corresponding propertyexactly or, in
case of \var{name}, the regular expression must match the window
title. An asterisk '*' indicates that a winprop where the field is
not specified (or is itself an asterisk in case of the first three
fields) is tried.

\begin{center}
\begin{tabular}{llll}
\hline
\var{class} & \var{role} & \var{instance} & \var{name} \\
\hline
  E	       & E          & E              & E \\
  E	       & E          & E              & * \\
  E	       & E          & *              & E \\
  E	       & E          & *              & * \\
  E	       & *          & E              & E \\
  E	       & *          & E              & * \\
  E	       & *          & *              & E \\
  \vdots       & \vdots     & \vdots         & etc. \\
\end{tabular}
\end{center}

If there are multiple winprops with other identification information 
the same but different \var{name}, the chosen winprop is arbitrary
among these.

To get this identification information for a particular window, you
may use the command \command{xprop WM_CLASS} and click on that
particular window.\footnote{This does not work for transients in
WIonFrames.} The class is the latter of the strings while
the instance is the former. To get the role -- few windows have
this property -- use the command \command{xprop WM_ROLE}.

\subsection{Supported winprops}

Ion currently knows the following winprops:

\index{switchto@\var{switchto}!winprop}
\index{transient-mode@\var{transient_mode}!winprop}
\index{target@\var{target}!winprop}
\index{transparent@\var{transparent}!winprop}
\index{acrobatic@\var{acrobatic}!winprop}
\index{max-size@\var{max_size}!winprop}
\index{aspect@\var{aspect}!winprop}
\index{ignore-resizeinc@\var{ignore_resizeinc}}

\begin{tabularx}{\textwidth}{llX}
    \hline
    Property & Type & Description\\\hline
    \var{switchto} &
    	boolean &
    	Should the window be switched to when it is created. \\
    \var{transient_mode} &
  	string &
    	"normal": No change in behaviour. "current": The window
	should be thought of as a transient for the current active
	client window (if any) even if it is not marked as a
	transient by the application. "off": The window should be
	handled as a normal window even if it is marked as a
	transient by the application. \\
    \var{target} &
    	string &
    	The name of an object (workspace, frame) that should manage 
	windows of this type. \\
    \var{transparent} &
    	boolean &
    	Should frames be made transparent when this window is selected? \\
    \var{acrobatic} &
    	boolean &
    	Set this to \code{true} for Acrobat Reader. It has an annoying
	habit of trying to manage its dialogs instead of setting them as
	transients and letting the window manager do its job, causing
	Ion and acrobat go a window-switching loop when a dialog is
	opened. \\
    \var{max_size} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied maximum size hint. \\
    \var{aspect} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied aspect ratio hint. \\
    \var{ignore_resizeinc} &
    	boolean &
    	Should application supplied size increments be ignored? \\
    \var{fullscreen} &
    	boolean &
    	Should the window be initially in full screen mode? \\
    \var{ignore_cfgrq} &
    	boolean &
    	Should configure requests on the window be ignored?
	Only has effect on windows on floatws:s. \\
\end{tabularx}

\subsection{Examples}

Acrobat Reader's manners aren't exactly good:
\begin{verbatim}
winprop{
    class = "AcroRead",
    instance = "documentShell",
    acrobatic = true,
}
\end{verbatim}

Place xterm started with '\code{-name sysmon}' and running a system
monitoring program in a specific frame:
\begin{verbatim}
winprop{
    class = "XTerm",
    instance = "sysmon",
    target = "sysmonframe",
}
\end{verbatim}


\section{The query library}
\index{querylib@\var{querylib}}

The query module does not implement any queries in itself, but provides
the function \fnref{query_query} to execute arbitrary queries. Some
standard queries implemented with this interface are available in 
'querylib' (\file{SHAREDIR/querylib.lua}). Most of these queries support
tab-completion and can be directly passed to the binding setup functions
for classes based on \type{WMPlex}.  These setup functions are at the moment:
\begin{itemize}
\item \fnref{global_bindings}
\item \fnref{mplex_bindings}, 
\item \fnref{genframe_bindings},
\item \fnref{ionframe_bindings} and
\item \fnref{floatframe_bindings}.
\end{itemize}

The default configuration puts most queries in \fnref{genframe_bindings}
while the exit and restart queries are in \fnref{global_bindings}.
For a listing of the functions, see section \ref{sec:querylibref} in the 
Function referece. 

Querylib also provides functions to generate more queries; for details see
the script.

\section{Menus}
\label{sec:menus}

\subsection{Defining menus}

\index{menus}
\index{defmenu@\code{defmenu}}
\index{menuentry@\code{menuentry}}
\index{submenu@\code{submenu}}
In the stock configuration file setup, menus are configured in the file
\file{ioncore-menus.lua} as previously mentioned. An example of a 
definition of a rather simple menu with a submenu is:
\begin{verbatim}
include("menulib")

defmenu("exitmenu", {
    menuentry("Restart", restart_wm),
    menuentry("Exit", exit_wm),
})

defmenu("mainmenu", {
    menuentry("Lock screen", make_exec_fn("xlock")),
    menuentry("Help", querylib.query_man),
    submenu("Exit", "exitmenu"),
})
\end{verbatim}

The \file{menulib} library must be loaded for some of the functions 
discussed here to be available.

The \fnref{defmenu} function is used to define a named menu that can later
be accessed with this name. The \fnref{menuentry} function is used to
create an entry in the menu with a title and an entry handler function to
be called when the menu entry is activated. If the functions discussed in
the next subsection are used to display the menu from a binding, the 
parameters that are passed to the function are that the binding handler was
passed. It is as if the function was called from that binding. 

The \fnref{submenu} function is used to insert a submenu at that point in
the menu. A menu with the given name must previously have been defined
with \fnref{defmenu}. (One could as well just pass a table with the menu
entries, but it is not encouraged.)

\subsection{Displaying menus}

\index{make_menu_fn@\code{make_menu_fn}}
\index{make_bigmenu_fn@\code{make_bigmenu_fn}}
\index{make_pmenu_fn@\code{make_pmenu_fn}}
Menus defined with the routines described in the previous subsection
should be bound to key and pointer actions by creating a bindable
function with one of the following routines: \fnref{make_menu_fn},
\fnref{make_bigmenu_fn} or \fnref{make_pmenu_fn}. The first two
create functions to display in-frame (or in-mplex more generally)
menus that appear on the bottom-left corner of the \type{WMPlex}
where the bound action occured. The difference between the two is
the different drawing engine style used. The last function creates
a pop-up menu display function and can only be bound to mouse press
actions.

An example of a binding to display a menu is:
\begin{verbatim}
global_bindings{
    kpress("F12", make_bigmenu_fn(``mainmenu'')),
}
\end{verbatim}

The low-level functions \fnref{menu_menu} and \fnref{menu_pmenu} can
also be used to display menus with different kinds of handlers and so
on, but most users should not need to be concerned with these.
If you use these functions note that they do not call the menu entry
handlers but pass the entry to a specified handler the responsibility
of which it is to decide what to do.


\section{Some common configuration tasks}

\subsection{Binding a key to execute a program}

Because the \fnref{exec} function immediately executes the argument string,
we must wrap this function in the bindings in the following way:
\begin{verbatim}
    kpress("SomeKey", function() exec("program --param") end)
\end{verbatim}
The \fnref{make_exec_fn} function can be used as a convenience; the
above is equivalent to
\begin{verbatim}
    kpress("SomeKey", make_exec_fn("program --param"))
\end{verbatim}
