
\chapter{Configuring Ion with Lua}

The following subsections are indended to help users to configure Ion.
As the reader probably knows, Ion uses Lua as a configuration and 
extension language. If you are new to Lua, you might first want to read
the the Lua manual at \url{http://www.lua.org/docs.html} and/or perhaps
some helpfull lua-users wiki pages (including a quick to read tutorial)
at \url{http://lua-users.org/wiki/}.

Section \ref{sec:conffiles} is an overview of the multiple configuration
files Ion uses.
How keys and mouse action are bound to functions is described in detail
in \ref{sec:bindings} and in section \ref{sec:winprops} winprops are
explained. For a reference on exported functions, see section
\ref{sec:exports}.

\section{The configuration files}
\label{sec:conffiles}

Ion (development branch) stores its stock configuration files and other
Lua code in \file{/usr/local/ion-devel/etc/ion-devel/} unless you or the
OS package maintainer has modified the variables
\code{PREFIX}\index{PREFIX@\code{PREFIX}} or
\code{ETCDIR}\index{ETCDIR@\code{ETCDIR}} in
\file{system.mk}.\index{system.mk@\file{system.mk}}
In the former case you probably know where to find the files and in the
latter the OS package maintainer should have provided documentation to
point to the correct location. If these instructions don't point you
to the correct directory, the command \code{locate ioncore.lua} might help
provided \code{updatedb} has been run recently. User configuration files
go in \file{\~{}/.ion-devel/}. 

Ion always searches user configuration file directory before the stock
configuration file directory for files. Therefore, if you want to change
some setting, it is advised against that you modify the stock configuration
files in-place as subsequent installs of Ion will restore the stock
configuration files. Instead you should always make a copy of the stock
file in \file{\~{}/.ion-devel/} and modify this file.

The ioncore main binary and each module have their own configuration
files that should be used to configure that module. In addition, each
(non-Xinerama)\index{Xinerama} screen may have a separate
\file{draw.lua} configuration file.
When Ioncore looks for this file, it first checks if the file
\file{draw-\$DISPLAY.SCREEN.lua} exists. If it cannot find this file, it
uses \file{draw.lua}. \file{\$DISPLAY} here points to the X display
on which Ion is running. If Ion was started with the \file{-display}
argument, it is this string and otherwise the \var{DISPLAY} environment
variable but with possible screen number removed as this is replaced
with the \file{SCREEN} we're loading the configuration for.

The rest of the configuration files are as follows:

%\newlength{\foolength}
%\settowidth{\foolength}{ioncore-bindings.lua}
%\newlength{\barlength}
%\settowidth{\barlength}{ioncore.luaxxx}

\begin{tabularx}{\linewidth}{
      p{\widthof{ioncore-bindings.lua}}%
      p{\widthof{Loaded from}}%
      X}
    \hline
    File & Loaded from & Description \\
    \hline
    \file{ioncore.lua} & ioncore &
    The main configuration file \\
    %
    \file{ioncore-bindings.lua} & \file{ioncore.lua} &
    Global bindings are configured in this file; see section 
    \ref{sec:bindings}. \\
    %
    \file{kludges.lua} & \file{ioncore.lua}  &
    Settings to get some apps behave more nicely have been collected here.
    See section \ref{sec:winprops} for details on these ''winprops''. \\
    %
    \file{ionws.lua} & ionws\linebreak module  &
    Configuration file for the ionws module. (This module only
    supports configuring bindings.) \\
    %
    \file{floatws.lua} & floatws\linebreak module  &
    Configuration file for the floatws module. Only bindings and
    placement method (see \fnref{set_floatws_placement_method}) are
    configurable. \\
    %
    \file{common-frame-bindings.lua} & \file{ionws.lua} and
                                       \file{floatws.lua} &
    Bindings common to both workspace modules' frames. \\
    %
    \file{query.lua} & query module  &
    Configuration file for the query module. (Again, bindings only.) \\
    %
    \file{look-*.lua} & ioncore & 
    Drawing engine configuration files. The \file{draw.lua} files
    as explained above are usually linked to or are copies of one of
    these.
\end{tabularx}

Some of the files contain references to the file \file{querylib.lua}.
This file is installed in
\code{SHAREDIR}\index{SHAREDIR@\code{SHAREDIR}}
(\file{/usr/local/ion-devel/share/ion-devel/} by default)
among some other other \file{.lua} files that are an essential part of
Ion's code. Users who only want to change a few settings should not
need to modify the files in this directory. Nevertheless, it is
possible to override the files in \code{SHAREDIR} as it is on the search
path after \code{\~/.ion-devel} and \code{ETCDIR}.

There is one extra file in \code{SHAREDIR} that you may find usefull and
that is not loaded by default. This is \file{compat.lua} and it contains
some wrapper functions for backwards compatibility to make the process of
updating Ion a little less painfull. If you have have modified configuration
files that use some features no longer available in the latest Ion, you may
just load this file (with \code{include("compat.lua")} at the beginning of
\file{ioncore.lua}, for example) instead of immediately updating your
configuration files. However, the wrappers will be removed eventually
(maybe about two months after adding them depending on the rate of new
releases) so you should nevertheless update your configuration files before
this happens.

\section{Keys and rodents}
\label{sec:bindings}

\subsection{Defining the bindings}

Keyboard- and mouse bindings are defined by calling various functions
that add a new set of bindings to a binding ``context'' (in lack of
a better name). These functions, their contexts and defining modules
are given in the following table. The last column additionally lists
the types of parameters the binding handler (explained later in this
section) gets if different from context:

\begin{tabularx}{\textwidth}{llX}
    \hline
    Module & Function & Context; parameter(s) \\
    \hline
    ioncore & \fnref{global_bindings} & \type{WScreen} \\
    ionws   & \fnref{ionws_bindings}  & All objects on \type{WIonWS}s;
    					parameters: the \type{WIonWS}
				        and a \type{WWindow} where the event
				        actually occured\\
            & \fnref{ionframe_bindings} & \type{WIonFrame}s; parameters: the
	    				\type{WIonFrame}. For actions on tabs
					this is followed by the \type{WRegion} 
					corresponding to the tab. \\
            & \fnref{ionframe_moveres_bindings} & \type{WIonFrame}s in resize mode \\
    floatws & \fnref{floatws_bindings} & All objects on \type{WFloatWS}s;
    					 parameters: the \type{WFloatWS}
				         and a \type{WWindow} where
					 the event actually occured, if any\\
    	    & \fnref{floatframe_bindings} & \type{WFloatFrame}; parameters
	    				similar to \code{ionframe_bindings}. \\
            & \fnref{floatframe_moveres_bindings} & \type{WFloatFrame}s in move/resize mode \\
    query   & \fnref{input_bindings} & \type{WInput}s \\
            & \fnref{wedln_bindings} & \type{WEdln}s \\
\end{tabularx}

In the default configuration, global bindings are set from a file
included from the Ioncore main configuration file (\file{ioncore.lua}),
\file{ioncore-bindings.lua}.
The rest of the bindings are set in the defining modules' main
configuration files (\file{modulename.lua}). The module bindings
must indeed be set during the execution of the module configuration
file as the functions to set the bindings are not available before
the module is loaded and the modules check that there are enough
bindings defined after reading the configuration file and
refuse to load otherwise.

The resize mode bindings are used when either
\fnref{ionframe_begin_resize} or \fnref{floatframe_begin_resize} 
depending on the type of object has been called until the mode
ends. Only the resize and move functions may be used in these modes.

Each of the functions given above has a single argument: a table
listing other tables describing the bindings. While it is possible
to directly construct these tables, the following convenience
functions are provided. 

Key presses:
\begin{itemize}
    \item \fnref{kpress}\code{(keyspec, func)},
    \item \fnref{kpress_waitrel}\code{(keyspec, func)} and
    \item \fnref{submap}\code{(keyspec)\{ ... more key bindings ... \}}.
\end{itemize}
Mouse actions:
\begin{itemize}
    \item \fnref{mclick}\code{(buttonspec, func, [, area])},
    \item \fnref{mdblclick}\code{(buttonspec, func, [, area])}, 
    \item \fnref{mpress}\code{(buttonspec, func, [, area])} and
    \item \fnref{mdrag}\code{(buttonspec, func, [, area])}.
\end{itemize}

The actions that most of these functions correspond to should be clear
and as explained in the reference, \fnref{kpress_waitrel} is simply
\fnref{kpress} with a flag set instructing Ioncore wait for all
modifiers to be released before processing any further actions.
This is to stop one from accidentally calling e.g.
\fnref{region_close} multiple times in a row. The \fnref{submap}
function actually returns another function that expects a table
as an argument. Alternatively you could use
\code{submap2(keyspec, \{ ... \})}.

The parameters \var{keyspec} and \var{buttonspec} are explained below
in detail. The parameter \var{func} is the handler for the binding.
It should expect as parameter(s) objects the types of which depend
on the context as defined in the above table.

The optional string parameter \var{area} may be used to specify a more
precise location where the mouse action should occur for the binding to
take place.
Currently only \fnref{ionframe_bindings} and \fnref{floatframe_bindings}
support any meaningfull values for this parameter. The allowed values
are in this case
\code{"border"}, \code{"tab"}, \code{"empty_tab"}, \code{"client"} and
\code{nil} (for the whole frame).

\subsection{Key and button specifications}

As seen above, the functions that create key binding specifications require
a \var{keyspec} argument. This argument should be a string containing the
name of a key as listed in the X header file \file{keysymdef.h}%
\footnote{This file can usually be found in the directory
\file{/usr/X11R6/include/X11/}.} without the \code{XK_} prefix.
\index{keysymdef.h@\file{keysymdef.h}}
Most of the key names are quite intuitive while some are not. For example,
the \key{Enter} key on the main part of the keyboard has the less common
name \key{Return} while the one one the numpad is called \key{KP\_Enter}.

The \var{keyspec} string may optionally have multiple ''modifier'' names
followed by a plus sign (\code{+}) as a prefix. X defines the following
modifiers:
\begin{quotation}
\key{Shift}, \key{Control}, \key{Mod1} to \key{Mod5},
\key{AnyModifier} and \key{Lock}.
\index{Shift@\key{Shift}}
\index{Control@\key{Control}}
\index{Mod-n@\key{Mod-n}}
\index{AnyModifier@\key{AnyModifier}}
\index{Lock@\key{Lock}}
\end{quotation}

X allows binding all of these modifiers to almost any key and while this
list of modifiers does not explicitly list keys such as 
\key{Alt}\index{Alt@\key{Alt}} that are common on modern keyboards, such
keys are bound to one of the \key{Mod-n}. On systems running XFree86
\key{Alt} is usually \key{Mod1}. On Suns \key{Mod1} is the diamond key
and \key{Alt} something else. One of the ''flying window'' keys on so
called Windows-keyboards is probably mapped to \key{Mod3} if you have
such a key. Use the program \file{xmodmap}\index{xmodmap@\file{xmodmap}}
to find out what exactly is bound where. \key{AnyModifier} is usually
used in submaps to indicate that it doesn't matter which modifier keys
are pressed, if any.

Ion ignores the \key{Lock} modifier and any \key{Mod-n} modifiers bound
to 
\key{NumLock}\index{NumLock@\key{NumLock}} or
\key{ScrollLock}\index{ScrollLock@\key{ScrollLock}}
by default because such\footnote{Completely useless keys that should be
  gotten rid of in the author's opinion.} locking keys may otherwise
cause confusion.

Button specifications are similar to key definitions but now
instead of specifying modifiers and a key, you specify modifiers
and one of the button names \key{Button1} to
\key{Button5}\index{Button-n@\key{Button-n}}.


\subsection{An example}

As an example, let's look at an extract from the default bindings for
\type{WIonFrame}s:

\begin{verbatim}
ionframe_bindings{
    kpress(DEFAULT_MOD .. "R", ionframe_begin_resize),
    kpress(DEFAULT_MOD .. "S",
           function(frame) ionframe_split(frame, "bottom") end),

    submap(DEFAULT_MOD .. "K"){
        kpress("AnyModifier+X", ionframe_close),
        kpress("AnyModifier+S",
               function(frame) ionframe_split(frame, "right") end),
    },
    
    mclick("Button1", genframe_p_switch_tab, "tab"),
    mdrag("Button1", genframe_p_tabdrag, "tab"),
    mdrag("Button1", genframe_p_resize, "border"),
    
    mclick("Button2", genframe_p_switch_tab, "tab"),
    mdrag("Button2", genframe_p_tabdrag, "tab"),
    
    mdrag(DEFAULT_MOD .. "Button3", genframe_p_resize),
}
\end{verbatim}

\subsection{A further note on the default binding configuration}

The variable \code{DEFAULT_MOD} in the above listing defaults to
\code{"Mod1+"} and is set in \file{ioncore.lua}. Changing this
variable allows to easily change the the modifier used by all bindings
in the default configuration that use modifiers. Quite a few people
prefer to use the Windows keys as modifiers because many applications
already use \key{Alt}. Nevertheless, \key{Mod1} is the default as a
key bound to it is available virtually everywhere.

\subsection{Client window bindings}

As client windows do not have function to set their bindings, it is
necessary to call client window functions by specifying the bindings
somewhere else (e.g. \fnref{global_bindings} or \fnref{ionframe_bindings}
and \fnref{floatframe_bindings}), and then looking up the previously
active leaf node in Ion's hierarchy of objects, starting from the
first parameter to the callback with
\fnref{region_get_active_leaf}%
\index{region-get-active-leaf@\code{region_get_active_leaf}}.
The convenience function \code{make_active_leaf_fn} is provided to
make a function to do this. The following two binding definitions are
equivalent:

\begin{verbatim}
global_bindings {
    kpress("Mod1+C", function(scr)
                         lf=region_get_active_leaf(scr)
                         region_close(lf)
                     end
          ),
    kpress("Mod1+C", make_active_leaf_fn(region_close)),
}
\end{verbatim}

The function
\fnref{genframe_current}
\index{genframe-current@\code{genframe_curent}}
may also be used to get the current managed region of a frame. (The
object returned by this function is not the same as what
\fnref{region_get_active_leaf} would return if there are transients!)


\section{Winprops}
\label{sec:winprops}

\subsection{Classes, roles and instances}

The so-called ''winprops''\index{Winprops} can be used to change how
specific windows are handled and to set up some kludges to deal with
badly behaving applications. They are defined by calling the function
\code{winprop} with a table containing the properties to set and the
necessary information to identify a window. This identification
information is more specifically the
\var{class}\index{class@\var{class}!winprop},
\var{role}\index{role@\var{role}!winprop} and
\var{instance}\index{instance@\var{instance}!winprop}
of the window. It is not necessary to specify all of these; if one is
not specified or is the string \code{"*"} that particular field matches
all windows. For a window with identification information \var{id}, Ion
looks for a matching winprop in the following order:
\begin{verbatim}
for _, c in {id.class, "*"} do
    for _, r in {id.role, "*"} do
        for _, i in {id.instance, "*"} do
            -- Check for winprop matching (c, r, i)
        end
    end
end
\end{verbatim}

To get this identification information for a particular window, you
may use the command \command{xprop WM_CLASS} and click on that
particular window.\footnote{This does not work for transients in
WIonFrames.} The class is the latter of the strings while
the instance is the former. To get the role -- few windows have
this property -- use the command \command{xprop WM_ROLE}.

\subsection{Supported winprops}

Ion currently knows the following winprops:

\index{switchto@\var{switchto}!winprop}
\index{transient-mode@\var{transient_mode}!winprop}
\index{target@\var{target}!winprop}
\index{transparent@\var{transparent}!winprop}
\index{acrobatic@\var{acrobatic}!winprop}
\index{max-size@\var{max_size}!winprop}
\index{aspect@\var{aspect}!winprop}
\index{ignore-resizeinc@\var{ignore_resizeinc}}

\begin{tabularx}{\textwidth}{llX}
    \hline
    Property & Type & Description\\\hline
    \var{switchto} &
    	boolean &
    	Should the window be switched to when it is created. \\
    \var{transient_mode} &
  	string &
    	"normal": No change in behaviour. "current": The window
	should be thought of as a transient for the current active
	client window (if any) even if it is not marked as a
	transient by the application. "off": The window should be
	handled as a normal window even if it is marked as a
	transient by the application. \\
    \var{target} &
    	string &
    	The name of an object (workspace, frame) that should manage 
	windows of this type. \\
    \var{transparent} &
    	boolean &
    	Should frames be made transparent when this window is selected? \\
    \var{acrobatic} &
    	boolean &
    	Set this to \code{true} for Acrobat Reader. It has an annoying
	habit of trying to manage its dialogs instead of setting them as
	transients and letting the window manager do its job, causing
	Ion and acrobat go a window-switching loop when a dialog is
	opened. \\
    \var{max_size} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied maximum size hint. \\
    \var{aspect} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied aspect ratio hint. \\
    \var{ignore_resizeinc} &
    	boolean &
    	Should application supplied size increments be ignored? \\
    \var{fullscreen} &
    	boolean &
    	Should the window be initially in full screen mode? \\
\end{tabularx}

\subsection{Examples}

Acrobat Reader's manners aren't exactly good:
\begin{verbatim}
winprop{
    class = "AcroRead",
    instance = "documentShell",
    acrobatic = true,
}
\end{verbatim}

Place xterm started with '\code{-name sysmon}' and running a system
monitoring program in a specific frame:
\begin{verbatim}
winprop{
    class = "XTerm",
    instance = "sysmon",
    target = "sysmonframe",
}
\end{verbatim}


\section{QueryLib}
\index{QueryLib@\var{QueryLib}}

While the query module only exportes the primitive function
\fnref{query_query}, QueryLib, in \file{querylib.lua}, implements some
standard queries, most with completion support. These functions can be
directly passed as arguments to the binding creation functions
(\code{kpress} and so on) for \fnref{ionframe_bindings} and
\fnref{floatframe_bindings}. For a listing of these, see section
\ref{sec:querylibref}.
