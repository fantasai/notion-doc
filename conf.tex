
\chapter{Basic configuration}
\label{chap:config}

This chapter should help your configure Ion to your liking. As  the your
probably already know, Ion uses Lua as a configuration and extension 
language. If you're new to it, you might first want to read some Lua 
documentation as already suggested and pointed to in the Introduction
before continuing with this chapter.

Section \ref{sec:conffiles} is an overview of the multiple configuration
files Ion uses and as a perhaps more understandable introduction to the
general layout of the configuration files, a walk-through of the main 
configuration file \file{ion.lua} is provided in section 
\ref{sec:walkthrough}.
How keys and mouse action are bound to functions is described in detail
in \ref{sec:bindings} and in section \ref{sec:winprops} winprops are
explained. For a reference on exported functions, see section
\ref{sec:exports}.

\section{The configuration files}
\label{sec:conffiles}

Ion3, to which document applies, stores its stock configuration files in
\file{/usr/local/etc/ion3/} unless you, the OS package maintainer or 
whoever  installed the package on the system has modified the variables
\code{PREFIX}\index{PREFIX@\code{PREFIX}} or
\code{ETCDIR}\index{ETCDIR@\code{ETCDIR}} in
\file{system.mk}\index{system.mk@\file{system.mk}} before compiling Ion.
In the first case you probably know where to find the files and in 
the other case the system administrator or the OS package maintainer
should  have provided documentation to point to the correct location. 
If these instructions are no help in locating the correct directory, 
the command \code{locate cfg_ion.lua} might help provided \code{updatedb} 
has been run recently. 

User configuration files go in \file{\~{}/.ion3/}. 
Ion always searches the user configuration file directory before the stock
configuration file directory for files. Therefore, if you want to change
some setting, it is advised against that you modify the stock configuration
files in-place as subsequent installs of Ion will restore the stock
configuration files. Instead you should always make a copy of the stock
file in \file{\~{}/.ion3/} and modify this file. When searching
for a file, if no extension or path component is given, compiled \file{.lc} 
files are attempted before \file{.lua} files.

All the configuration files are named \file{cfg\_*.lua} with the ''\file{*}''
part varying. The configuration file for each module \file{mod\_modname} is
\file{cfg\_modname.lua}, with \file{modname} varying by the module in
question. The following table summarises these and other configuration
files:

\begin{tabularx}{\linewidth}{
      p{\widthof{cfg-bindings.lua}}%
      X}
    \hline
    File & Description \\
    \hline
    \file{cfg\_ion.lua} & 
    The main configuration file \\
    %
    \file{cfg\_bindings.lua} & 
    Most of Ion's bindings are configured here. Bindings that are
    specific to some module are configured in the module's configuration
    file. For details, see section \ref{sec:bindings}. \\
    %
    \file{cfg\_menus.lua} & 
    Menu definitions; see section \ref{sec:menus}. \\
    %
    \file{cfg\_kludges.lua} & 
    Settings to get some applications behave more nicely have been 
    collected here. See section \ref{sec:winprops}. \\
    %
    \file{cfg\_ionws.lua} 
    \file{cfg\_floatws.lua} 
    \file{cfg\_panews.lua} 
    \file{cfg\_query.lua} 
    \file{cfg\_menu.lua} 
    \file{cfg\_dock.lua} 
    \file{cfg\_statusbar.lua} 
    \dots & Configuration files for different modules. \\
\end{tabularx}

Additionally, there's \file{look.lua} that configures the drawing engine,
but for details in it see chapter \ref{chap:gr}.

\section{A walk through \file{cfg\_ion.lua}}
\label{sec:walkthrough}

As already mentioned \file{cfg\_ion.lua} is Ion's main configuration
file. Some basic 'feel' settings are usually configured there and
the necessary modules and other configuration files configuring some 
more specific aspects of Ion are loaded there. In this section we
take a walk through the stock \file{cfg\_ion.lua}.

The first thing that is done in that file is set

\begin{verbatim}
MOD1="Mod1+"
MOD2=""
\end{verbatim}
This causes most of Ion's key bindings to use \key{Mod1} as the
modifier key. If \code{MOD2} is set, it is used as modifier for the keys
that don't normally use a modifier. for details on modifiers and key 
binding setup in general see section \ref{sec:bindings}.

Next we do some basic feel configuration:

\begin{verbatim}
ioncore.set{
    dblclick_delay=250,
    kbresize_delay=1500,
}
\end{verbatim}

These two will set the delay between button presses in a double click, and
the timeout to quit resize mode in milliseconds.

\begin{verbatim}
ioncore.set{
    opaque_resize=true,
    warp=true,
}
\end{verbatim}

The first of these two settings enables opaque resize mode: in move/resize
move frames and other objects mirror you actions immediately. If opaque
resize is disabled, a XOR rubber band is shown during the mode instead.
This will, unfortunately, cause Ion to also grab the X server and has some
side effects.

\begin{verbatim}
ioncore.set{
    default_ws_type="WIonWS",
}
\end{verbatim}

This will set the default workspace type to \type{WIonWS} -- tiled workspaces.

To actually be able to do something besides display windows in full screen
mode, we must next load some modules:

\begin{verbatim}
dopath("mod_query")
dopath("mod_menu")
dopath("mod_ionws")
dopath("mod_floatws")
dopath("mod_panews")
dopath("mod_statusbar")
--dopath("mod_dock")
--dopath("mod_sp")
\end{verbatim}

As already mentioned, each of these modules have their own configuration
files. Finally, additional configuration files are loaded:

\begin{verbatim}
dopath("cfg_kludges")
dopath("cfg_bindings")
dopath("cfg_menus")
\end{verbatim}

Bindings and menus are defined in \file{cfg\_bindings.lua} and
\file{cfg\_menus.lua}. Details on making such definitions follow in
sections \ref{sec:bindings} and \ref{sec:menus}, respectively. 
some kludges or ''winprops'' to make some applications behave better
under Ion are colledted in \file{cfg\_kludges.lua}; see section
\ref{sec:winprops} for details. In addition to these, this file
lists quite a few statements of the form
\begin{verbatim}
ioncore.defshortening("[^:]+: (.*)(<[0-9]+>)", "$1$2$|$1$<...$2")
\end{verbatim}
These are used to configure how Ion attempts to shorten window titles
when they do not fit in a Tab. The first argument is a POSIX regular
expression that is used to match against the title and the next is
a rule to construct a new title of a match occurs. This particular
rule is used to shorten e.g. 'Foo: barbaz<3>' to 'barba{\ldots}<3>'; for
details see the function reference entry for \fnref{add_shortenrule}.

\section{Keys and rodents}
\label{sec:bindings}

In the stock configuration file setup, most key and mouse bindings are set
from the file \file{cfg\_bindings.lua} while module-specific bindings
are set from the modules' main configuration files (\file{cfg\_modname.lua}).
This, however, does not have to be so as long as the module has been
loaded prior to defining any module-specific bindings.

Bindings are defined by calling the function 
\fnrefx{ioncore}{defbindings} with the ''context'' of the
bindings and the a table of new bindings to make. The context is simply
string indicating one of the classes of regions (or a modes such as
\type{WMoveresMode}) introduced in section \ref{sec:objects}, and fully
listed in appendix \ref{app:fullhierarchy}, although not all define
a binding map. For example, the following skeleton would be used to 
define new bindings for all frames:

\begin{verbatim}
defbindings("WFrame", {
    -- List of bindings to make goes here.
})
\end{verbatim}

There has been some confusion among users about the need to define the
''context'' for each binding, so let me try to explain this design
decision here. The thing is that if there was a just a simple 'bind this 
key to this action' method without knowledge of the context, some 
limitations would have to be made on the available actions and writing 
custom handlers would be more complicated. In addition one may want to 
bind the same function to different key for different types of objects.
Indeed, the workspace and frame tab switching functions are the same both
classes being based on \type{WMPlex}, and in the stock configuration the 
switch to $n$:th workspaces is bound to \key{Mod1+n} while the switch to 
$n$:th tab is bound to the sequence \key{Mod1+k n}.

The following subsections describe how to construct elements of the
binding table. Note that \fnrefx{ioncore}{defbindings} adds
the the newly defined bindings to the previous bindings of the context,
overriding duplicates. To unbind an event, set the handler parameter
to \code{nil} for each of the functions to be described in the following
subsections.

Also note that when multiple objects want to handle a binding, the 
innermost (when the root window is considered the outermost) active object
in the parent--child hierarchy (see Figure \ref{fig:parentship}) of objects 
gets to handle the action.


\subsection{Binding handlers and special variables}

Unlike in Ion2, in Ion3 binding handlers are not normally passed as as
''anonymous functions'', although this is still possible. The preferred
method now is to pass thecode of the handler as a string. Two special 
variables are avilable in this code. These are

\begin{description}
    \item[\_] (underscore) Reference to the object on which the 
      binding was triggered. The object is of the same class as the the
      context of the \fnrefx{ioncore}{defbindings} call
      defining the binding.
    \item[\_sub] Usually, the currently active child of the 
      object referenced by \code{_}, but sometimes (e.g. mouse actions
      on tabs of frames) something else relevant to the action triggering
      the binding.
\end{description}

For example, supposing '\code{_}' is a \type{WFrame}, the following
handler should move the active window right, if possible:

\begin{verbatim}
"_:inc_index(_sub)"
\end{verbatim}

\subsection{Guards}

To suppress error messages, each binding handler may also be accompanied
by a ''guard'' that blocks the handler from being called when the guard 
condition is not met. Currently the following guards are supported:

\begin{description}
    \item[\_sub:non-nil] to assert that \code{_sub} must be set.
    \item[\_sub:SomeClass] to assert that \code{_sub} must be member
      of class \type{SomeClass}.
\end{description}
      


\subsection{Defining the bindings}
\label{sec:binddef}

The descriptions of the individual bindings in the binding table argument
to \fnrefx{ioncore}{defbindings} should be constructed with the following
functions.

Key presses:
\begin{itemize}
    \item \fnref{kpress}\code{(keyspec, handler [, guard])},
    \item \fnref{kpress_wait}\code{(keyspec, handler [, guard])} and
    \item \fnref{submap}\code{(keyspec, \{ ... more key bindings ... \})}.
\end{itemize}
Mouse actions:
\begin{itemize}
    \item \fnref{mclick}\code{(buttonspec, handler [, guard])},
    \item \fnref{mdblclick}\code{(buttonspec, handler [, guard])}, 
    \item \fnref{mpress}\code{(buttonspec, handler [, guard])} and
    \item \fnref{mdrag}\code{(buttonspec, handler [, guard])}.
\end{itemize}

The actions that most of these functions correspond to should be clear
and as explained in the reference, \fnref{kpress_wait} is simply
\fnref{kpress} with a flag set instructing Ioncore wait for all
modifiers to be released before processing any further actions.
This is to stop one from accidentally calling e.g.
\fnref{WRegion.close} multiple times in a row. The \fnref{submap}
function is used to define submaps or ''prefix maps''. The second
argument to this function is table listing the key press actions
(\fnref{kpress}) in the submap

The parameters \var{keyspec} and \var{buttonspec} are explained below
in detail. The parameter \var{handler} is the handler for the binding,
and the optional parameter \var{guard} its guard. These should normally
be strings as explained above. 

\subsection{Examples}

For example, to just bind the key \key{Mod1+1} to switch to the first
workspace and \key{Mod1+Right} to the next workspace, you would make the
following call
\begin{verbatim}
defbindings("WScreen", {
    kpress("Mod1+Right", "_:switch_next()"),
    kpress("Mod1+1", "_:switch_nth(1)"),
})
\end{verbatim}

Note that \code{_:switch_nth(1)} is the same as calling
\fnref{WMPlex.switch_next}\code{(_, 1)} as \type{WScreen} inherits
\type{WMPlex} and this is where the function is actually defined.

Similarly to the above example, to bind the key sequence \key{Mod1+k n} 
switch to the next managed object within a frame, and \key{Mod1+k 1} to the
first, you would issue the following call:
\begin{verbatim}
defbindings("WFrame", {
    submap("Mod1+K", {
        kpress("Right", "_:switch_next()"),
        kpress("1", "_:switch_nth(1)"),
   }),
})
\end{verbatim}


\subsection{Key specifications}

As seen above, the functions that create key binding specifications require
a \var{keyspec} argument. This argument should be a string containing the
name of a key as listed in the X header file \file{keysymdef.h}%
\footnote{This file can usually be found in the directory
\file{/usr/X11R6/include/X11/}.} without the \code{XK_} prefix.
\index{keysymdef.h@\file{keysymdef.h}}
Most of the key names are quite intuitive while some are not. For example,
the \key{Enter} key on the main part of the keyboard has the less common
name \key{Return} while the one the numpad is called \key{KP\_Enter}.

The \var{keyspec} string may optionally have multiple ''modifier'' names
followed by a plus sign (\code{+}) as a prefix. X defines the following
modifiers:
\begin{quotation}
\key{Shift}, \key{Control}, \key{Mod1} to \key{Mod5},
\key{AnyModifier} and \key{Lock}.
\index{Shift@\key{Shift}}
\index{Control@\key{Control}}
\index{ModN@\key{ModN}}
\index{AnyModifier@\key{AnyModifier}}
\index{Lock@\key{Lock}}
\end{quotation}

X allows binding all of these modifiers to almost any key and while this
list of modifiers does not explicitly list keys such as 
\key{Alt}\index{Alt@\key{Alt}} that are common on modern keyboards, such
keys are bound to one of the \key{ModN}. On systems running XFree86
\key{Alt} is usually \key{Mod1}. On Suns \key{Mod1} is the diamond key
and \key{Alt} something else. One of the ''flying window'' keys on so
called Windows-keyboards is probably mapped to \key{Mod3} if you have
such a key. Use the program \file{xmodmap}\index{xmodmap@\file{xmodmap}}
to find out what exactly is bound where. \key{AnyModifier} is usually
used in submaps to indicate that it doesn't matter which modifier keys
are pressed, if any.

Ion ignores the \key{Lock} modifier and any \key{ModN} ($N=1{\ldots} 5$)
bound to \key{NumLock}\index{NumLock@\key{NumLock}} or
\key{ScrollLock}\index{ScrollLock@\key{ScrollLock}}
by default because such\footnote{Completely useless keys that should be
gotten rid of in the author's opinion.} locking keys may otherwise
cause confusion.


\subsection{Button specifications}

Button specifications are similar to key definitions but now
instead of specifying modifiers and a key, you specify modifiers
and one of the button names \key{Button1} to
\key{Button5}\index{Button-n@\key{Button-n}}. Additionally the
specification may end with an optional area name following an @-sign.
Only frames currently support areas, and the supported values in this
case are
\code{"border"}, \code{"tab"}, \code{"empty_tab"}, \code{"client"} and
\code{nil} (for the whole frame).

For example, the following code binds dragging a tab with the first 
button pressed to initiate tab drag\&drop handling:

\begin{verbatim}
defbindings("WFrame", {
    mdrag("Button1@tab", "_:p_tabdrag()"),
})
\end{verbatim}

\subsection{A further note on the default binding configuration}

The default binding configuration contains references to the variables
\code{MOD1} and \code{MOD2} instead of directly using the default
values of \code{"Mod1+"} and \code{""} (nothing). As explained in
section \ref{sec:walkthrough}, the definitions of these variables
appear in \file{cfg\_ion.lua}. This way you can easily change the the
modifiers used by all bindings in the default configuration without 
changing the whole binding configuration. Quite a few people prefer 
to use the Windows keys as modifiers because many applications already
use \key{Alt}. Nevertheless, \key{Mod1} is the default as a key bound 
to it is available virtually everywhere.


\subsection{Client window bindings}

As client windows do not have function to set their bindings, it is
necessary to call client window functions by specifying the bindings
somewhere else. In the stock configuration file setup this is done
among \type{WMPlex} bindings, setting the guard to \code{_sub:WClientWin}
and using \code{_sub} to refer to the client window.

For example, the full screen toggle key is bound like this:

\begin{verbatim}
defbindings("WMPlex", {
    kpress_wait("Mod1+Return", 
                "_:toggle_fullscreen()", "_sub:WClientWin"),
})    
\end{verbatim}


\section{Winprops}
\label{sec:winprops}

\subsection{Classes, roles and instances}

The so-called ''winprops''\index{Winprops} can be used to change how
specific windows are handled and to set up some kludges to deal with
badly behaving applications. They are defined by calling the function
\code{winprop} with a table containing the properties to set and the
necessary information to identify a window. This identification
information is more specifically the
\var{class}\index{class@\var{class}!winprop},
\var{role}\index{role@\var{role}!winprop},
\var{instance}\index{instance@\var{instance}!winprop} and
\var{name}
of the window. The \var{name} field is a Lua-style regular expression
matched against the window's title and the rest are strings that must
exactly much the corresponding window information. It is not necessary
to specify all of these fields.

Ion looks for a matching winprop in the order listed by the following
table. An 'E' indicates that the field must be set in the winprop
and it must match the window's corresponding property exactly or, in
case of \var{name}, the regular expression must match the window
title. An asterisk '*' indicates that a winprop where the field is
not specified (or is itself an asterisk in case of the first three
fields) is tried.

\begin{center}
\begin{tabular}{llll}
\hline
\var{class} & \var{role} & \var{instance} & \var{name} \\
\hline
  E	       & E          & E              & E \\
  E	       & E          & E              & * \\
  E	       & E          & *              & E \\
  E	       & E          & *              & * \\
  E	       & *          & E              & E \\
  E	       & *          & E              & * \\
  E	       & *          & *              & E \\
  \vdots       & \vdots     & \vdots         & etc. \\
\end{tabular}
\end{center}

If there are multiple winprops with other identification information 
the same but different \var{name}, the longest match is chosen.

\subsection{Finding window identification with \command{xprop}}

\index{xprop}
To get the identification information required for winprops, in case of
normally framed windows you may use the command \command{xprop WM_CLASS} 
and click on the particular window of interest. The class is the latter of
the strings while the instance is the former. To get the role -- few windows
have this property -- use the command \command{xprop WM_ROLE}.

\index{transient}
So-called ''transient windows'' are usually short-lived dialogs (although
some programs abuse this property) that have a parent window that they are
''transient for''. On tiled workspaces Ion displays these windows 
simulatenously with the parent window at the bottom of the same frame.
Unfortunately \command{xprop} is stupid and can't cope with this situation,
returning the parent window's properties when the transient is clicked on.
For this reason you'll have to do a little extra work to get the properties
for that window.\footnote{There's a patch to \command{xprop} to
fix this, but nothing seems to be happening with respect to including it in 
XFree86.}

If you can guess the title of the transient, the simplest solution
is to use the \key{Mod1+A} query (\fnref{querylib.query_attachclient})
to attach it directly to a frame. Another easy solution is to create
a \type{WFloatWS} and run the program for this once. A little more
complicated solution is to run the following code in the \key{Mod1+F3}
(\fnref{querylib.query_lua)} Lua code execution query, assuming there's
only one transient (all on one line):

\begin{verbatim}
local id=_:current():managed_list()[1]:get_ident();
query_message(_, id.class..'.'..id.instance);
\end{verbatim}

Role and name can be retrieved similarly (see the documentation for
\fnref{WClientWin.get_ident} or \fnref{WRegion.name}). Role may not
always be set.

Finally, it should be mentioned that too many authors these days
''forget'' to set this vital identification to anything meaningful:
everything except name is the same for all of the programs's 
windows, for example.


\subsection{Supported winprops}

Ion currently knows the following winprops:

\index{switchto@\var{switchto}!winprop}
\index{jumpto@\var{jumpto}!winprop}
\index{transient-mode@\var{transient_mode}!winprop}
\index{target@\var{target}!winprop}
\index{transparent@\var{transparent}!winprop}
\index{acrobatic@\var{acrobatic}!winprop}
\index{max-size@\var{max_size}!winprop}
\index{aspect@\var{aspect}!winprop}
\index{ignore-resizeinc@\var{ignore_resizeinc}}

\begin{tabularx}{\textwidth}{llX}
    \hline
    Property & Type & Description\\\hline
    \var{switchto} &
    	boolean &
        Should a newly mapped client window be switched to within
        its frame. \\
    \var{jumpto} &
    	boolean &
        Should a newly created client window always be made
        active, even if the allocated frame isn't. \\
    \var{transient_mode} &
  	string &
    	"normal": No change in behaviour. "current": The window
	should be thought of as a transient for the current active
	client window (if any) even if it is not marked as a
	transient by the application. "off": The window should be
	handled as a normal window even if it is marked as a
	transient by the application. \\
    \var{target} &
    	string &
    	The name of an object (workspace, frame) that should manage 
	windows of this type. \\
    \var{transparent} &
    	boolean &
    	Should frames be made transparent when this window is selected? \\
    \var{acrobatic} &
    	boolean &
    	Set this to \code{true} for Acrobat Reader. It has an annoying
	habit of trying to manage its dialogs instead of setting them as
	transients and letting the window manager do its job, causing
	Ion and acrobat go a window-switching loop when a dialog is
	opened. \\
    \var{max_size} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied maximum size hint. \\
    \var{aspect} &
    	table &
        The table should contain the entries \var{w} and \var{h} that
	override application-supplied aspect ratio hint. \\
    \var{ignore_resizeinc} &
    	boolean &
    	Should application supplied size increments be ignored? \\
    \var{fullscreen} &
    	boolean &
    	Should the window be initially in full screen mode? \\
    \var{ignore_cfgrq} &
    	boolean &
    	Should configure requests on the window be ignored?
	Only has effect on windows on floatws:s. \\
    \var{transients_at_top} &
    	boolean &
    	When transients are managed by the client window itself (as it
	is the case on tiled workspaces), should the transients be
	placed at the top of the window instead of bottom? \\
\end{tabularx}

\subsection{Some common examples}

\subsubsection{Acrobat Reader}

The following is absolutely necessary for Acrobat reader:

\begin{verbatim}
winprop{
    class = "AcroRead",
    instance = "documentShell",
    acrobatic = true,
}
\end{verbatim}

\subsubsection{Fixing a Mozilla Firebird transient}

Mozilla Firebird (0.7) incorrectly does not set the \code{WM_TRANSIENT_FOR} 
property for the dialog that is used to ask the action to take for a file.
It, however, sets the the property point to the main window for the save
dialog. This can be annoying and confusing, as the first dialog is not 
closed before the second is displayed.

We'd like the first dialog to be transient to the main window. The closest
we can get to that is to consider it transient to the current window (if
there's one). Unfortunately Firebird does not set any meaningful classes, 
instances or roles for the windows, so we'll have to rely on an ugly title
match.

\begin{verbatim}
winprop{
    class = "MozillaFirebird-bin",
    name = "Opening .*",
    transient_mode = "current",
}
\end{verbatim}

\subsubsection{Forcing newly created windows in named frames}

The following winprop should place xterm started with command-line parameter
'\code{-name sysmon}' and running a system monitoring program in a
particular frame:
\begin{verbatim}
winprop{
    class = "XTerm",
    instance = "sysmon",
    target = "sysmonframe",
}
\end{verbatim}

For this example to work, we have to somehow create a frame with the 
name \code{sysmonframe}. One way to do this is to make the following
call in the \key{Mod1+F3} Lua code query:

\begin{verbatim}
querylib.query_renameframe(_)
\end{verbatim}

Recall that \code{_} points to the multiplexer (frame or screen) in which 
the query was opened. Running this code should open a new query prefilled
with the current name of the frame. In our example we would change the 
name to \code{sysmonframe}, but we could just as well have used the 
default name formed from the frame's class name and an instance number.

\section{Menus}
\label{sec:menus}

\subsection{Defining menus}

\index{menus}
\index{defmenu@\code{defmenu}}
\index{menuentry@\code{menuentry}}
\index{submenu@\code{submenu}}
In the stock configuration file setup, menus are configured in the file
\file{cfg\_menus.lua} as previously mentioned. An example of a 
definition of a rather simple menu with a submenu is:

\begin{verbatim}
defmenu("exitmenu", {
    menuentry("Restart", "ioncore.restart()"),
    menuentry("Exit", "ioncore.shutdown()"),
})

defmenu("mainmenu", {
    menuentry("Lock screen", "ioncore.exec('xlock')"),
    menuentry("Help", "mod_query.query_man(_)"),
    submenu("Exit", "exitmenu"),
})
\end{verbatim}

The \file{mod\_menu} module must be loaded for one to be able to define
menus.

The \fnrefx{mod_menu}{defmenu} function is used to define a named
menu that can later be accessed with this name. The 
\fnrefx{mod_menu}{menuentry} function is used to create an entry in the menu
with a title and an entry handler function to be called when the menu entry
is activated. The parameters to the handler are similar to those of binding
handlers, and usually the same as those of the binding that opened the menu.

The \fnref{mod_menu}{submenu} function is used to insert a submenu at that 
point in the menu. (One could as well just pass a table with the menu
entries, but it is not encouraged.)

\subsection{Special menus}

The \file{menulib} library predefines the following special menus.
These can be used as the menus defined as above.

\begin{tabularx}{\linewidth}{lX}
    \hline
    Menu name & Description \\
    \hline
    \code{windowlist} & 
    List of all client windows. Activating an entry jumps to that window. \\
    \code{workspacelist} & 
    List of all workspaces. Activating an entry jumps to that workspaces. \\
    \code{stylemenu} &
    List of available \file{look-*.lua} style files. Activating an entry
    loads that style and ask to save the selection. \\
\end{tabularx}


\subsection{Displaying menus}
\label{sec:menudisp}

TODO


